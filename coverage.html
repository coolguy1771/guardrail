
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>guardrail: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/coolguy1771/guardrail/cmd/guardrail/analyze.go (87.0%)</option>
				
				<option value="file1">github.com/coolguy1771/guardrail/cmd/guardrail/main.go (75.0%)</option>
				
				<option value="file2">github.com/coolguy1771/guardrail/cmd/guardrail/validate.go (96.2%)</option>
				
				<option value="file3">github.com/coolguy1771/guardrail/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file4">github.com/coolguy1771/guardrail/pkg/analyzer/analyzer.go (64.9%)</option>
				
				<option value="file5">github.com/coolguy1771/guardrail/pkg/analyzer/mapper.go (99.1%)</option>
				
				<option value="file6">github.com/coolguy1771/guardrail/pkg/kubernetes/client.go (69.4%)</option>
				
				<option value="file7">github.com/coolguy1771/guardrail/pkg/kubernetes/context.go (0.0%)</option>
				
				<option value="file8">github.com/coolguy1771/guardrail/pkg/parser/parser.go (97.6%)</option>
				
				<option value="file9">github.com/coolguy1771/guardrail/pkg/reporter/reporter.go (100.0%)</option>
				
				<option value="file10">github.com/coolguy1771/guardrail/pkg/validator/nist_rules.go (91.6%)</option>
				
				<option value="file11">github.com/coolguy1771/guardrail/pkg/validator/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "k8s.io/apimachinery/pkg/runtime"

        "github.com/coolguy1771/guardrail/pkg/analyzer"
        "github.com/coolguy1771/guardrail/pkg/kubernetes"
        "github.com/coolguy1771/guardrail/pkg/parser"
)

const outputSeparatorLength = 80

//nolint:gochecknoglobals // CLI flags need to be global for Cobra
var (
        analyzeFile      string
        analyzeDirectory string
        analyzeCluster   bool
        kubeconfig       string
        kubectx          string
        subject          string
        showRoles        bool
        riskLevel        string
        noColor          bool
)

//nolint:gochecknoglobals // Cobra commands must be global
var analyzeCmd = &amp;cobra.Command{
        Use:   "analyze",
        Short: "Analyze RBAC permissions and explain what subjects can do",
        Long: `Analyze RoleBindings and ClusterRoleBindings to understand what permissions
are granted to users, service accounts, and groups. Provides plain English
explanations of what each permission allows.`,
        RunE: runAnalyze,
}

// init registers the 'analyze' CLI command and its flags, and binds them to Viper configuration keys for RBAC permission analysis.
//
//nolint:gochecknoinits // Cobra requires init for command registration
func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(analyzeCmd)

        analyzeCmd.Flags().StringVarP(&amp;analyzeFile, "file", "f", "", "Path to a single RBAC manifest file")
        analyzeCmd.Flags().StringVarP(&amp;analyzeDirectory, "dir", "d", "", "Path to a directory containing RBAC manifests")
        analyzeCmd.Flags().BoolVarP(&amp;analyzeCluster, "cluster", "c", false, "Analyze live cluster RBAC")
        analyzeCmd.Flags().StringVar(&amp;kubeconfig, "kubeconfig", "", "Path to kubeconfig file")
        analyzeCmd.Flags().StringVar(&amp;kubectx, "context", "", "Kubernetes context to use")
        analyzeCmd.Flags().
                StringVarP(&amp;subject, "subject", "s", "", "Filter by subject name (user, group, or service account)")
        analyzeCmd.Flags().BoolVar(&amp;showRoles, "show-roles", false, "Show detailed role information")
        analyzeCmd.Flags().StringVar(&amp;riskLevel, "risk-level", "", "Filter by risk level (low, medium, high, critical)")
        analyzeCmd.Flags().BoolVar(&amp;noColor, "no-color", false, "Disable colored output")

        _ = viper.BindPFlag("analyze.file", analyzeCmd.Flags().Lookup("file"))
        _ = viper.BindPFlag("analyze.directory", analyzeCmd.Flags().Lookup("dir"))
        _ = viper.BindPFlag("analyze.cluster", analyzeCmd.Flags().Lookup("cluster"))
        _ = viper.BindPFlag("analyze.kubeconfig", analyzeCmd.Flags().Lookup("kubeconfig"))
        _ = viper.BindPFlag("analyze.context", analyzeCmd.Flags().Lookup("context"))
        _ = viper.BindPFlag("analyze.subject", analyzeCmd.Flags().Lookup("subject"))
        _ = viper.BindPFlag("analyze.show-roles", analyzeCmd.Flags().Lookup("show-roles"))
        _ = viper.BindPFlag("analyze.risk-level", analyzeCmd.Flags().Lookup("risk-level"))
        _ = viper.BindPFlag("analyze.no-color", analyzeCmd.Flags().Lookup("no-color"))
}</span>

// runAnalyze executes the RBAC analysis command, processing input from a file, directory, or live Kubernetes cluster, and outputs permission analysis results in the specified format.
// It validates input options, initializes the analyzer, performs permission analysis, applies subject and risk level filters, and outputs results as JSON or human-readable text.
// Returns an error if input validation, parsing, analysis, or output fails.
func runAnalyze(cmd *cobra.Command, _ []string) error <span class="cov6" title="10">{
        fileArg := viper.GetString("analyze.file")
        directoryArg := viper.GetString("analyze.directory")
        clusterArg := viper.GetBool("analyze.cluster")
        kubeconfigArg := viper.GetString("analyze.kubeconfig")
        kubectxArg := viper.GetString("analyze.context")
        subjectArg := viper.GetString("analyze.subject")
        showRolesArg := viper.GetBool("analyze.show-roles")
        riskLevelArg := viper.GetString("analyze.risk-level")
        outputFormat := viper.GetString("output")

        // Validate input options
        inputCount := 0
        if fileArg != "" </span><span class="cov3" title="3">{
                inputCount++
        }</span>
        <span class="cov6" title="10">if directoryArg != "" </span><span class="cov5" title="7">{
                inputCount++
        }</span>
        <span class="cov6" title="10">if clusterArg </span><span class="cov0" title="0">{
                inputCount++
        }</span>

        <span class="cov6" title="10">if inputCount == 0 </span><span class="cov1" title="1">{
                return errors.New("must specify one of --file, --dir, or --cluster")
        }</span>
        <span class="cov6" title="9">if inputCount &gt; 1 </span><span class="cov1" title="1">{
                return errors.New("cannot specify multiple input sources")
        }</span>

        <span class="cov6" title="8">var a *analyzer.Analyzer
        var err error

        if clusterArg </span><span class="cov0" title="0">{
                // Analyze live cluster
                a, err = createClusterAnalyzer(kubeconfigArg, kubectxArg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov6" title="8"> {
                // Analyze files
                a, err = createFileAnalyzer(fileArg, directoryArg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Analyze permissions
        <span class="cov6" title="8">ctx := context.Background()
        // Note: The kubectx flag value is already passed to kubernetes.NewClient() above,
        // which handles context switching internally. This block is kept for potential
        // future use where we might need to pass context-specific options.

        permissions, err := a.AnalyzePermissions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to analyze permissions: %w", err)
        }</span>

        // Apply filters
        <span class="cov6" title="8">permissions = filterPermissions(permissions, subjectArg, riskLevelArg)

        // Output results
        var writer io.Writer = os.Stdout
        if cmd != nil </span><span class="cov6" title="8">{
                writer = cmd.OutOrStdout()
        }</span>

        <span class="cov6" title="8">switch outputFormat </span>{
        case "json":<span class="cov1" title="1">
                return outputJSON(permissions, writer)</span>
        default:<span class="cov5" title="7">
                return outputHumanReadable(permissions, showRolesArg, writer)</span>
        }
}

// createClusterAnalyzer creates an analyzer for live cluster analysis.
func createClusterAnalyzer(kubeconfigArg, kubectxArg string) (*analyzer.Analyzer, error) <span class="cov0" title="0">{
        client, err := kubernetes.NewClient(kubeconfigArg, kubectxArg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %w", err)
        }</span>
        <span class="cov0" title="0">return analyzer.NewAnalyzer(client.GetRBACReader()), nil</span>
}

// createFileAnalyzer creates an analyzer for file-based analysis.
func createFileAnalyzer(fileArg, directoryArg string) (*analyzer.Analyzer, error) <span class="cov6" title="8">{
        var objects []runtime.Object
        var err error

        if fileArg != "" </span><span class="cov2" title="2">{
                objects, err = parseFile(fileArg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse file: %w", err)
                }</span>
        } else<span class="cov5" title="6"> {
                objects, err = parseDirectory(directoryArg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse directory: %w", err)
                }</span>
        }

        <span class="cov6" title="8">return analyzer.NewAnalyzerFromObjects(objects), nil</span>
}

// parseFile parses a Kubernetes YAML manifest file and returns the contained runtime objects.
// Returns an error if the file cannot be parsed.
func parseFile(filename string) ([]runtime.Object, error) <span class="cov2" title="2">{
        p := parser.New()
        return p.ParseFile(filename)
}</span>

// parseDirectory walks through the specified directory, parses all YAML files into Kubernetes runtime objects, and returns the aggregated objects.
// Files that fail to parse are skipped with a warning; the function continues processing remaining files.
func parseDirectory(directory string) ([]runtime.Object, error) <span class="cov5" title="6">{
        var allObjects []runtime.Object
        p := parser.New()
        failedParses := 0

        err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="30">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="30">if !info.IsDir() &amp;&amp; (filepath.Ext(path) == ".yaml" || filepath.Ext(path) == ".yml") </span><span class="cov9" title="24">{
                        var objects []runtime.Object
                        objects, err = p.ParseFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: Failed to parse %s: %v\n", path, err)
                                failedParses++
                                return nil
                        }</span>
                        <span class="cov9" title="24">allObjects = append(allObjects, objects...)</span>
                }
                <span class="cov9" title="30">return nil</span>
        })

        <span class="cov5" title="6">if failedParses &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "\n%d file(s) failed to parse in directory '%s'.\n", failedParses, directory)
        }</span>

        <span class="cov5" title="6">return allObjects, err</span>
}

// filterPermissions returns a filtered slice of SubjectPermissions based on the specified subject name and risk level.
// Only permissions matching both filters (if provided) are included in the result.
func filterPermissions(
        permissions []analyzer.SubjectPermissions,
        subjectFilter, riskFilter string,
) []analyzer.SubjectPermissions <span class="cov7" title="13">{
        var filtered []analyzer.SubjectPermissions

        for _, perm := range permissions </span><span class="cov10" title="35">{
                // Apply subject filter
                if subjectFilter != "" </span><span class="cov7" title="12">{
                        if perm.Subject.Name != subjectFilter </span><span class="cov6" title="8">{
                                continue</span>
                        }
                }

                // Apply risk level filter
                <span class="cov9" title="27">if riskFilter != "" </span><span class="cov6" title="8">{
                        if string(perm.RiskLevel) != riskFilter </span><span class="cov5" title="5">{
                                continue</span>
                        }
                }

                <span class="cov8" title="22">filtered = append(filtered, perm)</span>
        }

        <span class="cov7" title="13">return filtered</span>
}

// outputJSON writes the analyzed subject permissions and a summary to stdout in indented JSON format.
// Returns an error if encoding or writing fails.
func outputJSON(permissions []analyzer.SubjectPermissions, w io.Writer) error <span class="cov1" title="1">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(map[string]any{
                "subjects": permissions,
                "summary":  getSummary(permissions),
        })
}</span>

// outputHumanReadable prints a human-readable summary and detailed analysis of RBAC permissions for each subject, including risk distribution and optional rule details.
// Returns an error only if output fails.
//

func outputHumanReadable(permissions []analyzer.SubjectPermissions, showRoles bool, w io.Writer) error <span class="cov5" title="7">{
        if len(permissions) == 0 </span><span class="cov1" title="1">{
                fmt.Fprintln(w, "No RBAC permissions found matching the criteria.")
                return nil
        }</span>

        // Print summary
        <span class="cov5" title="6">summary := getSummary(permissions)
        fmt.Fprintf(w, "üìä RBAC Analysis Summary\n")
        fmt.Fprintf(w, "========================\n")
        fmt.Fprintf(w, "Total Subjects: %d\n", summary.TotalSubjects)
        fmt.Fprintf(w, "Risk Distribution:\n")
        fmt.Fprintf(w, "  üî¥ Critical: %d\n", summary.CriticalRisk)
        fmt.Fprintf(w, "  üü† High: %d\n", summary.HighRisk)
        fmt.Fprintf(w, "  üü° Medium: %d\n", summary.MediumRisk)
        fmt.Fprintf(w, "  üü¢ Low: %d\n", summary.LowRisk)
        fmt.Fprintf(w, "\n")

        // Print detailed analysis for each subject
        for i, subjectPerm := range permissions </span><span class="cov7" title="13">{
                if i &gt; 0 </span><span class="cov5" title="7">{
                        fmt.Fprintf(w, "\n%s\n\n", strings.Repeat("‚îÄ", outputSeparatorLength))
                }</span>

                <span class="cov7" title="13">printSubjectAnalysis(subjectPerm, showRoles, w)</span>
        }

        <span class="cov5" title="6">return nil</span>
}

// printSubjectAnalysis displays a detailed analysis of a subject's permissions, including risk level, roles, and optionally detailed rule information.
// It prints the subject's kind, name, namespace, risk level, and a breakdown of each permission with associated roles and bindings.
// If showRoles is true, detailed permission rules are printed; otherwise, a summary is shown.
//

func printSubjectAnalysis(subjectPerm analyzer.SubjectPermissions, showRoles bool, w io.Writer) <span class="cov7" title="13">{
        // Print subject header
        riskIcon := getRiskIcon(subjectPerm.RiskLevel)
        fmt.Fprintf(w, "%s %s: %s\n", riskIcon, subjectPerm.Subject.Kind, subjectPerm.Subject.Name)

        if subjectPerm.Subject.Namespace != "" </span><span class="cov4" title="4">{
                fmt.Fprintf(w, "   Namespace: %s\n", subjectPerm.Subject.Namespace)
        }</span>
        <span class="cov7" title="13">fmt.Fprintf(w, "   Risk Level: %s\n", strings.ToUpper(string(subjectPerm.RiskLevel)))
        fmt.Fprintf(w, "   Total Permissions: %d\n\n", len(subjectPerm.Permissions))

        // Print permissions
        for _, perm := range subjectPerm.Permissions </span><span class="cov7" title="13">{
                fmt.Fprintf(w, "  üìã %s/%s", perm.RoleKind, perm.RoleName)
                if perm.Namespace != "" </span><span class="cov6" title="9">{
                        fmt.Fprintf(w, " (namespace: %s)", perm.Namespace)
                }</span>
                <span class="cov7" title="13">fmt.Fprintf(w, "\n")
                fmt.Fprintf(w, "     Scope: %s\n", perm.Scope)
                fmt.Fprintf(w, "     Bound via: %s/%s\n", perm.BindingKind, perm.BindingName)

                if showRoles &amp;&amp; len(perm.Rules) &gt; 0 </span><span class="cov3" title="3">{
                        fmt.Fprintf(w, "\n     üîç Detailed Permissions:\n")
                        for _, rule := range perm.Rules </span><span class="cov3" title="3">{
                                printRuleAnalysis(rule, "       ", w)
                        }</span>
                } else<span class="cov6" title="10"> if len(perm.Rules) &gt; 0 </span><span class="cov6" title="8">{
                        fmt.Fprintf(w, "     üìù Summary: %s\n", generatePermissionSummary(perm.Rules))
                }</span>
                <span class="cov7" title="13">fmt.Fprintf(w, "\n")</span>
        }
}

// printRuleAnalysis displays a detailed, human-readable analysis of a policy rule, including its description, risk level, concerns, and allowed actions with explanations and examples, using indentation and optional color coding for clarity.
//

func printRuleAnalysis(rule analyzer.PolicyRuleAnalysis, indent string, w io.Writer) <span class="cov3" title="3">{
        fmt.Fprintf(w, "%s‚Ä¢ %s\n", indent, rule.HumanReadable)
        fmt.Fprintf(w, "%s  Risk: %s\n", indent, strings.ToUpper(string(rule.SecurityImpact.Level)))

        if len(rule.SecurityImpact.Concerns) &gt; 0 </span><span class="cov1" title="1">{
                fmt.Fprintf(w, "%s  ‚ö†Ô∏è  Concerns: %s\n", indent, strings.Join(rule.SecurityImpact.Concerns, ", "))
        }</span>

        <span class="cov3" title="3">if len(rule.VerbExplanations) &gt; 0 </span><span class="cov3" title="3">{
                fmt.Fprintf(w, "%s  üîß Actions allowed:\n", indent)
                for _, verb := range rule.VerbExplanations </span><span class="cov5" title="7">{
                        riskColor := getColorForRisk(verb.RiskLevel)
                        fmt.Fprintf(w, "%s    - %s%s%s: %s\n", indent, riskColor, verb.Verb, resetColor(), verb.Explanation)
                        if verb.Examples != "" </span><span class="cov5" title="7">{
                                fmt.Fprintf(w, "%s      Example: %s\n", indent, verb.Examples)
                        }</span>
                }
        }
        <span class="cov3" title="3">fmt.Fprintf(w, "\n")</span>
}

// generatePermissionSummary returns a summary string describing the number of permission rules and how many are classified as high-risk or critical.
func generatePermissionSummary(rules []analyzer.PolicyRuleAnalysis) string <span class="cov6" title="8">{
        if len(rules) == 0 </span><span class="cov0" title="0">{
                return "No permissions"
        }</span>

        <span class="cov6" title="8">var summaryParts []string
        highRiskCount := 0

        for _, rule := range rules </span><span class="cov6" title="8">{
                if rule.SecurityImpact.Level == analyzer.RiskLevelHigh ||
                        rule.SecurityImpact.Level == analyzer.RiskLevelCritical </span><span class="cov3" title="3">{
                        highRiskCount++
                }</span>
        }

        <span class="cov6" title="8">summaryParts = append(summaryParts, fmt.Sprintf("%d permission rule(s)", len(rules)))

        if highRiskCount &gt; 0 </span><span class="cov3" title="3">{
                summaryParts = append(summaryParts, fmt.Sprintf("%d high-risk", highRiskCount))
        }</span>

        <span class="cov6" title="8">return strings.Join(summaryParts, ", ")</span>
}

// getRiskIcon returns an emoji icon representing the specified risk level.
func getRiskIcon(level analyzer.RiskLevel) string <span class="cov8" title="18">{
        switch level </span>{
        case analyzer.RiskLevelCritical:<span class="cov5" title="5">
                return "üî¥"</span>
        case analyzer.RiskLevelHigh:<span class="cov1" title="1">
                return "üü†"</span>
        case analyzer.RiskLevelMedium:<span class="cov1" title="1">
                return "üü°"</span>
        case analyzer.RiskLevelLow:<span class="cov6" title="10">
                return "üü¢"</span>
        default:<span class="cov1" title="1">
                return "‚ö™"</span>
        }
}

// isColorSupported returns true if colored output is enabled and supported by the terminal.
func isColorSupported() bool <span class="cov8" title="18">{
        if noColor </span><span class="cov3" title="3">{
                return false
        }</span>
        <span class="cov7" title="15">if os.Getenv("NO_COLOR") != "" </span><span class="cov1" title="1">{
                return false
        }</span>
        // Check if stdout is a terminal
        <span class="cov7" title="14">fi, err := os.Stdout.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="14">return (fi.Mode() &amp; os.ModeCharDevice) != 0</span>
}

// getColorForRisk returns the ANSI color code string corresponding to the given risk level if color output is supported; otherwise, it returns an empty string.
func getColorForRisk(riskLevel string) string <span class="cov6" title="8">{
        if !isColorSupported() </span><span class="cov6" title="8">{
                return ""
        }</span>
        <span class="cov0" title="0">switch riskLevel </span>{
        case "critical":<span class="cov0" title="0">
                return "\033[91m"</span> // Bright red
        case "high":<span class="cov0" title="0">
                return "\033[31m"</span> // Red
        case "medium":<span class="cov0" title="0">
                return "\033[33m"</span> // Yellow
        case "low":<span class="cov0" title="0">
                return "\033[32m"</span> // Green
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// resetColor returns the ANSI escape code to reset terminal text formatting if color output is supported, or an empty string otherwise.
func resetColor() string <span class="cov6" title="8">{
        if !isColorSupported() </span><span class="cov6" title="8">{
                return ""
        }</span>
        <span class="cov0" title="0">return "\033[0m"</span>
}

type AnalysisSummary struct {
        TotalSubjects int `json:"total_subjects"`
        CriticalRisk  int `json:"critical_risk"`
        HighRisk      int `json:"high_risk"`
        MediumRisk    int `json:"medium_risk"`
        LowRisk       int `json:"low_risk"`
}

// getSummary aggregates the total number of subjects and counts of each risk level from the provided permissions.
// It returns an AnalysisSummary with these aggregated values.
func getSummary(permissions []analyzer.SubjectPermissions) AnalysisSummary <span class="cov6" title="8">{
        summary := AnalysisSummary{
                TotalSubjects: len(permissions),
                CriticalRisk:  0,
                HighRisk:      0,
                MediumRisk:    0,
                LowRisk:       0,
        }

        for _, perm := range permissions </span><span class="cov8" title="23">{
                switch perm.RiskLevel </span>{
                case analyzer.RiskLevelCritical:<span class="cov5" title="7">
                        summary.CriticalRisk++</span>
                case analyzer.RiskLevelHigh:<span class="cov1" title="1">
                        summary.HighRisk++</span>
                case analyzer.RiskLevelMedium:<span class="cov3" title="3">
                        summary.MediumRisk++</span>
                case analyzer.RiskLevelLow:<span class="cov7" title="12">
                        summary.LowRisk++</span>
                }
        }

        <span class="cov6" title="8">return summary</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

//nolint:gochecknoglobals // CLI flags need to be global for Cobra
var cfgFile string

//nolint:gochecknoglobals // Cobra commands must be global
var rootCmd = &amp;cobra.Command{
        Use:   "guardrail",
        Short: "A Kubernetes RBAC validation tool",
        Long: `Guardrail is a Golang-based Kubernetes RBAC validation tool that helps teams
maintain secure, compliant, and well-structured RBAC configurations.`,
}

//nolint:gochecknoinits // Cobra requires init for command registration
func init() <span class="cov1" title="1">{
        cobra.OnInitialize(initConfig)

        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.guardrail.yaml)")
        rootCmd.PersistentFlags().StringP("output", "o", "text", "Output format (text, json, sarif)")

        _ = viper.BindPFlag("output", rootCmd.PersistentFlags().Lookup("output"))
}</span>

func initConfig() <span class="cov10" title="18">{
        if cfgFile != "" </span><span class="cov1" title="1">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov9" title="17"> {
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error getting home directory: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov9" title="17">viper.AddConfigPath(home)
                viper.AddConfigPath(".")
                viper.SetConfigType("yaml")
                viper.SetConfigName(".guardrail")</span>
        }

        <span class="cov10" title="18">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov1" title="1">{
                fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
        }</span>
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "k8s.io/apimachinery/pkg/runtime"

        "github.com/coolguy1771/guardrail/pkg/parser"
        "github.com/coolguy1771/guardrail/pkg/reporter"
        "github.com/coolguy1771/guardrail/pkg/validator"
)

//nolint:gochecknoglobals // CLI flags need to be global for Cobra
var (
        file      string
        directory string
)

//nolint:gochecknoglobals // Cobra commands must be global
var validateCmd = &amp;cobra.Command{
        Use:   "validate",
        Short: "Validate RBAC manifests",
        Long:  `Validate Kubernetes RBAC manifests against security and compliance rules.`,
        RunE:  runValidate,
}

//nolint:gochecknoinits // Cobra requires init for command registration
func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(validateCmd)

        validateCmd.Flags().StringVarP(&amp;file, "file", "f", "", "Path to a single RBAC manifest file")
        validateCmd.Flags().StringVarP(&amp;directory, "dir", "d", "", "Path to a directory containing RBAC manifests")

        _ = viper.BindPFlag("file", validateCmd.Flags().Lookup("file"))
        _ = viper.BindPFlag("directory", validateCmd.Flags().Lookup("dir"))
}</span>

//nolint:gocognit // Validation logic requires handling multiple cases
func runValidate(cmd *cobra.Command, _ []string) error <span class="cov10" title="12">{
        fileArg := viper.GetString("file")
        directoryArg := viper.GetString("directory")
        outputFormat := viper.GetString("output")

        if fileArg == "" &amp;&amp; directoryArg == "" </span><span class="cov1" title="1">{
                return errors.New("either --file or --dir must be specified")
        }</span>

        <span class="cov9" title="11">if fileArg != "" &amp;&amp; directoryArg != "" </span><span class="cov1" title="1">{
                return errors.New("cannot specify both --file and --dir")
        }</span>

        <span class="cov9" title="10">var files []string

        if fileArg != "" </span><span class="cov7" title="6">{
                files = append(files, fileArg)
        }</span> else<span class="cov6" title="4"> {
                err := filepath.Walk(directoryArg, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="9">{
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="8">if !info.IsDir() &amp;&amp; (filepath.Ext(path) == ".yaml" || filepath.Ext(path) == ".yml") </span><span class="cov6" title="5">{
                                files = append(files, path)
                        }</span>
                        <span class="cov8" title="8">return nil</span>
                })
                <span class="cov6" title="4">if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error walking directory: %w", err)
                }</span>
        }

        <span class="cov8" title="9">if len(files) == 0 </span><span class="cov1" title="1">{
                return errors.New("no YAML files found")
        }</span>

        // Create parser
        <span class="cov8" title="8">p := parser.New()

        // Parse all files
        var allObjects []runtime.Object
        for _, f := range files </span><span class="cov9" title="11">{
                objects, err := p.ParseFile(f)
                if err != nil </span><span class="cov1" title="1">{
                        fmt.Fprintf(os.Stderr, "Warning: Failed to parse %s: %v\n", f, err)
                        continue</span>
                }
                <span class="cov9" title="10">allObjects = append(allObjects, objects...)</span>
        }

        <span class="cov8" title="8">if len(allObjects) == 0 </span><span class="cov3" title="2">{
                return errors.New("no valid RBAC resources found in the provided files")
        }</span>

        // Create validator
        <span class="cov7" title="6">v := validator.New()

        // Validate all objects
        findings := v.ValidateAll(allObjects)

        // Create reporter based on output format
        var format reporter.Format
        switch outputFormat </span>{
        case "json":<span class="cov3" title="2">
                format = reporter.FormatJSON</span>
        case "sarif":<span class="cov1" title="1">
                format = reporter.FormatSARIF</span>
        default:<span class="cov4" title="3">
                format = reporter.FormatText</span>
        }

        <span class="cov7" title="6">r := reporter.New(format)

        // Get output writer
        var writer io.Writer = os.Stdout
        if cmd != nil </span><span class="cov4" title="3">{
                writer = cmd.OutOrStdout()
        }</span>

        // Report findings
        <span class="cov7" title="6">if err := r.Report(findings, writer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to report findings: %w", err)
        }</span>

        // Return error if high severity findings exist (for proper exit code)
        <span class="cov7" title="6">for _, finding := range findings </span><span class="cov8" title="7">{
                if finding.Severity == validator.SeverityHigh </span><span class="cov7" title="6">{
                        return errors.New("validation failed: found high severity issues")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package testutil

import (
        "fmt"
        "testing"

        "k8s.io/apimachinery/pkg/runtime"

        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NewTestRole creates a test Role with common defaults.
func NewTestRole(name, namespace string) *rbacv1.Role <span class="cov0" title="0">{
        return &amp;rbacv1.Role{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "rbac.authorization.k8s.io/v1",
                        Kind:       "Role",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Rules: []rbacv1.PolicyRule{},
        }
}</span>

// NewTestClusterRole creates a test ClusterRole with common defaults.
func NewTestClusterRole(name string) *rbacv1.ClusterRole <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRole{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "rbac.authorization.k8s.io/v1",
                        Kind:       "ClusterRole",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Rules: []rbacv1.PolicyRule{},
        }
}</span>

// NewTestRoleBinding creates a test RoleBinding with common defaults.
func NewTestRoleBinding(name, namespace string, roleRef rbacv1.RoleRef) *rbacv1.RoleBinding <span class="cov0" title="0">{
        return &amp;rbacv1.RoleBinding{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "rbac.authorization.k8s.io/v1",
                        Kind:       "RoleBinding",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                RoleRef:  roleRef,
                Subjects: []rbacv1.Subject{},
        }
}</span>

// NewTestClusterRoleBinding creates a test ClusterRoleBinding with common defaults.
func NewTestClusterRoleBinding(name string, roleRef rbacv1.RoleRef) *rbacv1.ClusterRoleBinding <span class="cov0" title="0">{
        return &amp;rbacv1.ClusterRoleBinding{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "rbac.authorization.k8s.io/v1",
                        Kind:       "ClusterRoleBinding",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                RoleRef:  roleRef,
                Subjects: []rbacv1.Subject{},
        }
}</span>

// AddRule adds a PolicyRule to a Role or ClusterRole.
func AddRule(obj runtime.Object, rule rbacv1.PolicyRule) <span class="cov0" title="0">{
        switch v := obj.(type) </span>{
        case *rbacv1.Role:<span class="cov0" title="0">
                v.Rules = append(v.Rules, rule)</span>
        case *rbacv1.ClusterRole:<span class="cov0" title="0">
                v.Rules = append(v.Rules, rule)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("AddRule: unsupported object type %T", obj))</span>
        }
}

// AddSubject adds a Subject to a RoleBinding or ClusterRoleBinding.
func AddSubject(obj runtime.Object, subject rbacv1.Subject) <span class="cov0" title="0">{
        switch v := obj.(type) </span>{
        case *rbacv1.RoleBinding:<span class="cov0" title="0">
                v.Subjects = append(v.Subjects, subject)</span>
        case *rbacv1.ClusterRoleBinding:<span class="cov0" title="0">
                v.Subjects = append(v.Subjects, subject)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("AddSubject: unsupported object type %T", obj))</span>
        }
}

// NewPolicyRule creates a PolicyRule with common defaults.
func NewPolicyRule(apiGroups, resources, verbs []string) rbacv1.PolicyRule <span class="cov0" title="0">{
        return rbacv1.PolicyRule{
                APIGroups: apiGroups,
                Resources: resources,
                Verbs:     verbs,
        }
}</span>

// NewSubject creates a Subject with common defaults.
func NewSubject(kind, name, namespace string) rbacv1.Subject <span class="cov0" title="0">{
        return rbacv1.Subject{
                Kind:      kind,
                Name:      name,
                Namespace: namespace,
        }
}</span>

// AssertEqual is a simple equality assertion helper.
func AssertEqual(t *testing.T, expected, actual interface{}, message string) <span class="cov0" title="0">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                t.Errorf("%s: expected %v, got %v", message, expected, actual)
        }</span>
}

// AssertNotNil asserts that a value is not nil.
func AssertNotNil(t *testing.T, value interface{}, message string) <span class="cov0" title="0">{
        t.Helper()
        if value == nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected non-nil value", message)
        }</span>
}

// AssertNil asserts that a value is nil.
func AssertNil(t *testing.T, value interface{}, message string) <span class="cov0" title="0">{
        t.Helper()
        if value != nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected nil, got %v", message, value)
        }</span>
}

// AssertContains asserts that a slice contains a specific value.
func AssertContains(t *testing.T, slice []string, value string, message string) <span class="cov0" title="0">{
        t.Helper()
        for _, v := range slice </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">t.Errorf("%s: expected slice to contain %s, but it didn't", message, value)</span>
}

// AssertLen asserts that a slice has a specific length.
func AssertLen(t *testing.T, slice interface{}, expectedLen int, message string) <span class="cov0" title="0">{
        t.Helper()
        var actualLen int
        switch v := slice.(type) </span>{
        case []string:<span class="cov0" title="0">
                actualLen = len(v)</span>
        case []rbacv1.PolicyRule:<span class="cov0" title="0">
                actualLen = len(v)</span>
        case []rbacv1.Subject:<span class="cov0" title="0">
                actualLen = len(v)</span>
        case []runtime.Object:<span class="cov0" title="0">
                actualLen = len(v)</span>
        default:<span class="cov0" title="0">
                t.Fatalf("%s: unsupported slice type", message)</span>
        }

        <span class="cov0" title="0">if actualLen != expectedLen </span><span class="cov0" title="0">{
                t.Errorf("%s: expected length %d, got %d", message, expectedLen, actualLen)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package analyzer

import (
        "context"
        "fmt"
        "slices"
        "sort"
        "strings"

        "k8s.io/apimachinery/pkg/runtime"

        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/coolguy1771/guardrail/pkg/kubernetes"
)

// Analyzer provides RBAC analysis capabilities.
type Analyzer struct {
        rbacReader kubernetes.RBACReader
        objects    []runtime.Object
}

// NewAnalyzer returns a new Analyzer that uses the provided RBACReader to fetch RBAC resources from a live Kubernetes cluster.
func NewAnalyzer(rbacReader kubernetes.RBACReader) *Analyzer <span class="cov4" title="3">{
        return &amp;Analyzer{
                rbacReader: rbacReader,
        }
}</span>

// NewAnalyzerFromObjects returns a new Analyzer that uses the provided Kubernetes runtime objects for RBAC analysis instead of fetching data from a live cluster.
func NewAnalyzerFromObjects(objects []runtime.Object) *Analyzer <span class="cov3" title="2">{
        return &amp;Analyzer{
                objects: objects,
        }
}</span>

// SubjectPermissions represents permissions for a specific subject.
type SubjectPermissions struct {
        Subject     rbacv1.Subject    `json:"subject"`
        Permissions []PermissionGrant `json:"permissions"`
        RiskLevel   RiskLevel         `json:"risk_level"`
}

// PermissionGrant represents a specific permission grant.
type PermissionGrant struct {
        RoleName    string               `json:"role_name"`
        RoleKind    string               `json:"role_kind"`
        Namespace   string               `json:"namespace,omitempty"`
        Scope       string               `json:"scope"`
        Rules       []PolicyRuleAnalysis `json:"rules"`
        BindingName string               `json:"binding_name"`
        BindingKind string               `json:"binding_kind"`
}

// PolicyRuleAnalysis provides detailed analysis of a policy rule.
type PolicyRuleAnalysis struct {
        APIGroups        []string          `json:"api_groups"`
        Resources        []string          `json:"resources"`
        Verbs            []string          `json:"verbs"`
        ResourceNames    []string          `json:"resource_names,omitempty"`
        NonResourceURLs  []string          `json:"non_resource_urls,omitempty"`
        HumanReadable    string            `json:"human_readable"`
        SecurityImpact   SecurityImpact    `json:"security_impact"`
        VerbExplanations []VerbExplanation `json:"verb_explanations"`
}

// VerbExplanation provides plain English explanation of what a verb allows.
type VerbExplanation struct {
        Verb        string `json:"verb"`
        Explanation string `json:"explanation"`
        RiskLevel   string `json:"risk_level"`
        Examples    string `json:"examples"`
}

// SecurityImpact describes the security implications of a rule.
type SecurityImpact struct {
        Level       RiskLevel `json:"level"`
        Description string    `json:"description"`
        Concerns    []string  `json:"concerns"`
}

// RiskLevel represents the risk level of permissions.
type RiskLevel string

const (
        RiskLevelLow      RiskLevel = "low"
        RiskLevelMedium   RiskLevel = "medium"
        RiskLevelHigh     RiskLevel = "high"
        RiskLevelCritical RiskLevel = "critical"

        // Risk priority values.
        riskPriorityCritical = 4
        riskPriorityHigh     = 3
        riskPriorityMedium   = 2
        riskPriorityLow      = 1
        riskPriorityDefault  = 0
)

// AnalyzePermissions analyzes all subjects and their permissions.
func (a *Analyzer) AnalyzePermissions(ctx context.Context) ([]SubjectPermissions, error) <span class="cov4" title="3">{
        var allBindings []runtime.Object
        var allRoles []runtime.Object

        if a.rbacReader != nil </span><span class="cov3" title="2">{
                // Fetch from cluster
                bindings, roles, err := a.fetchFromCluster(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to fetch from cluster: %w", err)
                }</span>
                <span class="cov1" title="1">allBindings = bindings
                allRoles = roles</span>
        } else<span class="cov1" title="1"> {
                // Use provided objects
                for _, obj := range a.objects </span><span class="cov3" title="2">{
                        switch obj.(type) </span>{
                        case *rbacv1.RoleBinding, *rbacv1.ClusterRoleBinding:<span class="cov1" title="1">
                                allBindings = append(allBindings, obj)</span>
                        case *rbacv1.Role, *rbacv1.ClusterRole:<span class="cov1" title="1">
                                allRoles = append(allRoles, obj)</span>
                        }
                }
        }

        // Build role map for quick lookup
        <span class="cov3" title="2">roleMap := a.buildRoleMap(allRoles)

        // Group permissions by subject
        subjectMap := make(map[string]*SubjectPermissions)

        for _, binding := range allBindings </span><span class="cov3" title="2">{
                permissions := a.analyzeBinding(binding, roleMap)
                for _, perm := range permissions </span><span class="cov3" title="2">{
                        key := a.getSubjectKey(perm.Subject)
                        if existing, exists := subjectMap[key]; exists </span><span class="cov0" title="0">{
                                existing.Permissions = append(existing.Permissions, perm.Permissions...)
                        }</span> else<span class="cov3" title="2"> {
                                subjectMap[key] = perm
                        }</span>
                }
        }

        // Calculate risk levels and convert to slice
        <span class="cov3" title="2">var result []SubjectPermissions
        for _, subject := range subjectMap </span><span class="cov3" title="2">{
                subject.RiskLevel = a.calculateRiskLevel(subject.Permissions)
                result = append(result, *subject)
        }</span>

        // Sort by risk level and subject name
        <span class="cov3" title="2">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                if result[i].RiskLevel != result[j].RiskLevel </span><span class="cov0" title="0">{
                        return a.getRiskPriority(result[i].RiskLevel) &gt; a.getRiskPriority(result[j].RiskLevel)
                }</span>
                <span class="cov0" title="0">return result[i].Subject.Name &lt; result[j].Subject.Name</span>
        })

        <span class="cov3" title="2">return result, nil</span>
}

// fetchFromCluster fetches RBAC resources from the cluster.
func (a *Analyzer) fetchFromCluster(ctx context.Context) ([]runtime.Object, []runtime.Object, error) <span class="cov3" title="2">{
        var bindings, roles []runtime.Object

        // Fetch RoleBindings
        roleBindings, err := a.rbacReader.RoleBindings("").
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to fetch role bindings: %w", err)
        }</span>
        <span class="cov1" title="1">for i := range roleBindings.Items </span><span class="cov1" title="1">{
                bindings = append(bindings, &amp;roleBindings.Items[i])
        }</span>

        // Fetch ClusterRoleBindings
        <span class="cov1" title="1">clusterRoleBindings, err := a.rbacReader.ClusterRoleBindings().
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to fetch cluster role bindings: %w", err)
        }</span>
        <span class="cov1" title="1">for i := range clusterRoleBindings.Items </span><span class="cov0" title="0">{
                bindings = append(bindings, &amp;clusterRoleBindings.Items[i])
        }</span>

        // Fetch Roles
        <span class="cov1" title="1">roleList, err := a.rbacReader.Roles("").List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to fetch roles: %w", err)
        }</span>
        <span class="cov1" title="1">for i := range roleList.Items </span><span class="cov1" title="1">{
                roles = append(roles, &amp;roleList.Items[i])
        }</span>

        // Fetch ClusterRoles
        <span class="cov1" title="1">clusterRoleList, err := a.rbacReader.ClusterRoles().
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to fetch cluster roles: %w", err)
        }</span>
        <span class="cov1" title="1">for i := range clusterRoleList.Items </span><span class="cov0" title="0">{
                roles = append(roles, &amp;clusterRoleList.Items[i])
        }</span>

        <span class="cov1" title="1">return bindings, roles, nil</span>
}

// buildRoleMap creates a map for quick role lookup.
func (a *Analyzer) buildRoleMap(roles []runtime.Object) map[string]runtime.Object <span class="cov4" title="3">{
        roleMap := make(map[string]runtime.Object)

        for _, role := range roles </span><span class="cov6" title="5">{
                switch r := role.(type) </span>{
                case *rbacv1.Role:<span class="cov6" title="4">
                        key := fmt.Sprintf("Role/%s/%s", r.Namespace, r.Name)
                        roleMap[key] = role</span>
                case *rbacv1.ClusterRole:<span class="cov1" title="1">
                        key := fmt.Sprintf("ClusterRole//%s", r.Name)
                        roleMap[key] = role</span>
                }
        }

        <span class="cov4" title="3">return roleMap</span>
}

// analyzeBinding analyzes a single binding and returns permissions for each subject.
func (a *Analyzer) analyzeBinding(binding runtime.Object, roleMap map[string]runtime.Object) []*SubjectPermissions <span class="cov4" title="3">{
        var result []*SubjectPermissions

        switch b := binding.(type) </span>{
        case *rbacv1.RoleBinding:<span class="cov4" title="3">
                result = a.analyzeRoleBinding(b, roleMap)</span>
        case *rbacv1.ClusterRoleBinding:<span class="cov0" title="0">
                result = a.analyzeClusterRoleBinding(b, roleMap)</span>
        }

        <span class="cov4" title="3">return result</span>
}

// analyzeRoleBinding analyzes a RoleBinding.
func (a *Analyzer) analyzeRoleBinding(
        binding *rbacv1.RoleBinding,
        roleMap map[string]runtime.Object,
) []*SubjectPermissions <span class="cov4" title="3">{
        var result []*SubjectPermissions

        // Find the referenced role
        var roleKey string
        var scope string
        if binding.RoleRef.Kind == "ClusterRole" </span><span class="cov0" title="0">{
                roleKey = fmt.Sprintf("ClusterRole//%s", binding.RoleRef.Name)
                scope = fmt.Sprintf("namespace:%s", binding.Namespace)
        }</span> else<span class="cov4" title="3"> {
                roleKey = fmt.Sprintf("Role/%s/%s", binding.Namespace, binding.RoleRef.Name)
                scope = fmt.Sprintf("namespace:%s", binding.Namespace)
        }</span>

        <span class="cov4" title="3">role, exists := roleMap[roleKey]
        if !exists </span><span class="cov1" title="1">{
                // Role not found, create a placeholder
                for _, subject := range binding.Subjects </span><span class="cov3" title="2">{
                        result = append(result, &amp;SubjectPermissions{
                                Subject: subject,
                                Permissions: []PermissionGrant{
                                        {
                                                RoleName:    binding.RoleRef.Name,
                                                RoleKind:    binding.RoleRef.Kind,
                                                Namespace:   binding.Namespace,
                                                Scope:       scope,
                                                Rules:       []PolicyRuleAnalysis{},
                                                BindingName: binding.Name,
                                                BindingKind: "RoleBinding",
                                        },
                                },
                                RiskLevel: RiskLevelLow, // Default to low risk for missing roles
                        })
                }</span>
                <span class="cov1" title="1">return result</span>
        }

        // Analyze the role
        <span class="cov3" title="2">var rules []rbacv1.PolicyRule
        switch r := role.(type) </span>{
        case *rbacv1.Role:<span class="cov3" title="2">
                rules = r.Rules</span>
        case *rbacv1.ClusterRole:<span class="cov0" title="0">
                rules = r.Rules</span>
        }

        <span class="cov3" title="2">analyzedRules := a.analyzeRules(rules)

        // Create permissions for each subject
        for _, subject := range binding.Subjects </span><span class="cov3" title="2">{
                result = append(result, &amp;SubjectPermissions{
                        Subject: subject,
                        Permissions: []PermissionGrant{
                                {
                                        RoleName:    binding.RoleRef.Name,
                                        RoleKind:    binding.RoleRef.Kind,
                                        Namespace:   binding.Namespace,
                                        Scope:       scope,
                                        Rules:       analyzedRules,
                                        BindingName: binding.Name,
                                        BindingKind: "RoleBinding",
                                },
                        },
                        RiskLevel: RiskLevelLow, // Will be calculated later in consolidatePermissions
                })
        }</span>

        <span class="cov3" title="2">return result</span>
}

// analyzeClusterRoleBinding analyzes a ClusterRoleBinding.
func (a *Analyzer) analyzeClusterRoleBinding(
        binding *rbacv1.ClusterRoleBinding,
        roleMap map[string]runtime.Object,
) []*SubjectPermissions <span class="cov0" title="0">{
        var result []*SubjectPermissions

        roleKey := fmt.Sprintf("ClusterRole//%s", binding.RoleRef.Name)
        role, exists := roleMap[roleKey]

        if !exists </span><span class="cov0" title="0">{
                // Role not found, create a placeholder
                for _, subject := range binding.Subjects </span><span class="cov0" title="0">{
                        result = append(result, &amp;SubjectPermissions{
                                Subject: subject,
                                Permissions: []PermissionGrant{
                                        {
                                                RoleName:    binding.RoleRef.Name,
                                                RoleKind:    binding.RoleRef.Kind,
                                                Namespace:   "", // Cluster-wide binding has no namespace
                                                Scope:       "cluster-wide",
                                                Rules:       []PolicyRuleAnalysis{},
                                                BindingName: binding.Name,
                                                BindingKind: "ClusterRoleBinding",
                                        },
                                },
                                RiskLevel: RiskLevelLow, // Default to low risk for missing roles
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov0" title="0">clusterRole, ok := role.(*rbacv1.ClusterRole)
        if !ok </span><span class="cov0" title="0">{
                // This should not happen, but handle it gracefully
                return result
        }</span>
        <span class="cov0" title="0">analyzedRules := a.analyzeRules(clusterRole.Rules)

        // Create permissions for each subject
        for _, subject := range binding.Subjects </span><span class="cov0" title="0">{
                result = append(result, &amp;SubjectPermissions{
                        Subject: subject,
                        Permissions: []PermissionGrant{
                                {
                                        RoleName:    binding.RoleRef.Name,
                                        RoleKind:    binding.RoleRef.Kind,
                                        Namespace:   "", // Cluster-wide binding has no namespace
                                        Scope:       "cluster-wide",
                                        Rules:       analyzedRules,
                                        BindingName: binding.Name,
                                        BindingKind: "ClusterRoleBinding",
                                },
                        },
                        RiskLevel: RiskLevelLow, // Will be calculated later in consolidatePermissions
                })
        }</span>

        <span class="cov0" title="0">return result</span>
}

// analyzeRules analyzes policy rules and provides human-readable explanations.
func (a *Analyzer) analyzeRules(rules []rbacv1.PolicyRule) []PolicyRuleAnalysis <span class="cov3" title="2">{
        var result []PolicyRuleAnalysis

        for _, rule := range rules </span><span class="cov3" title="2">{
                analysis := PolicyRuleAnalysis{
                        APIGroups:        rule.APIGroups,
                        Resources:        rule.Resources,
                        Verbs:            rule.Verbs,
                        ResourceNames:    rule.ResourceNames,
                        NonResourceURLs:  rule.NonResourceURLs,
                        HumanReadable:    "",                                                                  // Will be set below
                        SecurityImpact:   SecurityImpact{Level: RiskLevelLow, Description: "", Concerns: nil}, // Will be set below
                        VerbExplanations: nil,                                                                 // Will be set below
                }

                // Generate human-readable explanation
                analysis.HumanReadable = a.generateHumanReadableExplanation(rule)

                // Analyze security impact
                analysis.SecurityImpact = a.analyzeSecurityImpact(rule)

                // Explain each verb
                analysis.VerbExplanations = a.explainVerbs(rule.Verbs, rule.Resources)

                result = append(result, analysis)
        }</span>

        <span class="cov3" title="2">return result</span>
}

// generateHumanReadableExplanation creates a human-readable explanation of the rule.
func (a *Analyzer) generateHumanReadableExplanation(rule rbacv1.PolicyRule) string <span class="cov3" title="2">{
        var parts []string

        // Handle non-resource URLs
        if len(rule.NonResourceURLs) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("Access to API endpoints: %s", strings.Join(rule.NonResourceURLs, ", ")))
                return strings.Join(parts, ". ")
        }</span>

        // Handle resources
        <span class="cov3" title="2">resources := rule.Resources
        if len(resources) == 0 || (len(resources) == 1 &amp;&amp; resources[0] == "*") </span><span class="cov0" title="0">{
                parts = append(parts, "Access to ALL resources")
        }</span> else<span class="cov3" title="2"> {
                parts = append(parts, fmt.Sprintf("Access to: %s", strings.Join(resources, ", ")))
        }</span>

        // Handle API groups
        <span class="cov3" title="2">if apiGroupPart := a.formatAPIGroups(rule.APIGroups); apiGroupPart != "" </span><span class="cov3" title="2">{
                parts = append(parts, apiGroupPart)
        }</span>

        // Handle verbs
        <span class="cov3" title="2">verbs := rule.Verbs
        if len(verbs) == 1 &amp;&amp; verbs[0] == "*" </span><span class="cov0" title="0">{
                parts = append(parts, "with ALL permissions")
        }</span> else<span class="cov3" title="2"> {
                parts = append(parts, fmt.Sprintf("with permissions: %s", strings.Join(verbs, ", ")))
        }</span>

        // Handle resource names
        <span class="cov3" title="2">if len(rule.ResourceNames) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("limited to specific resources: %s", strings.Join(rule.ResourceNames, ", ")))
        }</span>

        <span class="cov3" title="2">return strings.Join(parts, " ")</span>
}

// explainVerbs provides detailed explanations for each verb.
func (a *Analyzer) explainVerbs(verbs []string, resources []string) []VerbExplanation <span class="cov3" title="2">{
        var explanations []VerbExplanation

        verbMap := map[string]VerbExplanation{
                "get": {
                        Verb:        "get",
                        Explanation: "Read/retrieve individual resources by name",
                        RiskLevel:   "low",
                        Examples:    "kubectl get pod my-pod, viewing resource details",
                },
                "list": {
                        Verb:        "list",
                        Explanation: "List/view all resources of this type",
                        RiskLevel:   "low",
                        Examples:    "kubectl get pods, viewing all resources in namespace",
                },
                "watch": {
                        Verb:        "watch",
                        Explanation: "Monitor resources for changes in real-time",
                        RiskLevel:   "low",
                        Examples:    "kubectl get pods -w, real-time monitoring",
                },
                "create": {
                        Verb:        "create",
                        Explanation: "Create new resources",
                        RiskLevel:   "medium",
                        Examples:    "kubectl create, kubectl apply (for new resources)",
                },
                "update": {
                        Verb:        "update",
                        Explanation: "Modify existing resources (full replacement)",
                        RiskLevel:   "medium",
                        Examples:    "kubectl replace, updating entire resource definition",
                },
                "patch": {
                        Verb:        "patch",
                        Explanation: "Partially modify existing resources",
                        RiskLevel:   "medium",
                        Examples:    "kubectl patch, kubectl apply (for existing resources)",
                },
                "delete": {
                        Verb:        "delete",
                        Explanation: "Remove/destroy resources",
                        RiskLevel:   "high",
                        Examples:    "kubectl delete, removing resources permanently",
                },
                "deletecollection": {
                        Verb:        "deletecollection",
                        Explanation: "Delete multiple resources at once",
                        RiskLevel:   "high",
                        Examples:    "kubectl delete pods --all, bulk deletion",
                },
                "bind": {
                        Verb:        "bind",
                        Explanation: "Bind resources (typically used for persistent volumes)",
                        RiskLevel:   "medium",
                        Examples:    "PVC binding to PV, resource allocation",
                },
                "escalate": {
                        Verb:        "escalate",
                        Explanation: "Grant additional permissions (privilege escalation)",
                        RiskLevel:   "critical",
                        Examples:    "Granting higher privileges, security risk",
                },
                "impersonate": {
                        Verb:        "impersonate",
                        Explanation: "Act as another user or service account",
                        RiskLevel:   "critical",
                        Examples:    "kubectl --as=user, assuming another identity",
                },
                "use": {
                        Verb:        "use",
                        Explanation: "Use specific resources (typically for security contexts)",
                        RiskLevel:   "medium",
                        Examples:    "Using pod security policies, security contexts",
                },
                "*": {
                        Verb:        "*",
                        Explanation: "ALL POSSIBLE ACTIONS - complete control over resources",
                        RiskLevel:   "critical",
                        Examples:    "Full administrative access, can do anything",
                },
        }

        // Adjust risk levels based on resources
        for _, verb := range verbs </span><span class="cov4" title="3">{
                if explanation, exists := verbMap[verb]; exists </span><span class="cov4" title="3">{
                        // Increase risk for sensitive resources
                        if a.isSensitiveResource(resources) </span><span class="cov0" title="0">{
                                explanation.RiskLevel = a.escalateRiskLevel(explanation.RiskLevel)
                        }</span>
                        <span class="cov4" title="3">explanations = append(explanations, explanation)</span>
                } else<span class="cov0" title="0"> {
                        // Unknown verb
                        explanations = append(explanations, VerbExplanation{
                                Verb:        verb,
                                Explanation: "Custom or unknown action",
                                RiskLevel:   "medium",
                                Examples:    "Custom resource verb, check API documentation",
                        })
                }</span>
        }

        <span class="cov3" title="2">return explanations</span>
}

// isSensitiveResource checks if resources are considered sensitive.
func (a *Analyzer) isSensitiveResource(resources []string) bool <span class="cov6" title="5">{
        sensitiveResources := map[string]bool{
                "*":                               true,
                "secrets":                         true,
                "serviceaccounts":                 true,
                "roles":                           true,
                "rolebindings":                    true,
                "clusterroles":                    true,
                "clusterrolebindings":             true,
                "nodes":                           true,
                "persistentvolumes":               true,
                "podsecuritypolicies":             true,
                "networkpolicies":                 true,
                "pods/exec":                       true,
                "pods/portforward":                true,
                "pods/proxy":                      true,
                "configmaps":                      true,
                "certificatesigningrequests":      true,
                "validatingwebhookconfigurations": true,
                "mutatingwebhookconfigurations":   true,
                "customresourcedefinitions":       true,
                "apiservices":                     true,
                "tokenreviews":                    true,
                "subjectaccessreviews":            true,
                "selfsubjectaccessreviews":        true,
                "nodes/proxy":                     true,
                "services/proxy":                  true,
                "namespaces":                      true,
                "events":                          true,
                "pods/attach":                     true,
                "pods/log":                        true,
                "priorityclasses":                 true,
                "storageclasses":                  true,
                "volumeattachments":               true,
                "csidrivers":                      true,
                "csinodes":                        true,
                "admissionregistration.k8s.io/*":  true,
                "authentication.k8s.io/*":         true,
                "authorization.k8s.io/*":          true,
                "certificates.k8s.io/*":           true,
                "rbac.authorization.k8s.io/*":     true,
                "policy/*":                        true,
                "security.openshift.io/*":         true,
                "oauth.openshift.io/*":            true,
                "user.openshift.io/*":             true,
                "ingresses":                       true,
                "ingressclasses":                  true,
                "nodes/status":                    true,
                "pods/eviction":                   true,
                "deployments/scale":               true,
                "replicasets/scale":               true,
                "statefulsets/scale":              true,
                "horizontalpodautoscalers":        true,
                "verticalpodautoscalers":          true,
                "poddisruptionbudgets":            true,
                "resourcequotas":                  true,
                "limitranges":                     true,
                "endpoints":                       true,
                "endpointslices":                  true,
                "nodes/metrics":                   true,
                "pods/metrics":                    true,
                "bindings":                        true,
                "componentstatuses":               true,
                "localsubjectaccessreviews":       true,
                "selfsubjectrulesreviews":         true,
                "subjectaccessreviews/*":          true,
                "clusterrolebindings/*":           true,
                "clusterroles/*":                  true,
                "rolebindings/*":                  true,
                "roles/*":                         true,
                "secrets/*":                       true,
                "serviceaccounts/*":               true,
                "serviceaccounts/token":           true,
        }

        for _, resource := range resources </span><span class="cov6" title="5">{
                if sensitiveResources[resource] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="5">return false</span>
}

// escalateRiskLevel increases the risk level.
func (a *Analyzer) escalateRiskLevel(currentLevel string) string <span class="cov0" title="0">{
        switch currentLevel </span>{
        case "low":<span class="cov0" title="0">
                return "medium"</span>
        case "medium":<span class="cov0" title="0">
                return "high"</span>
        case "high":<span class="cov0" title="0">
                return "critical"</span>
        default:<span class="cov0" title="0">
                return "critical"</span>
        }
}

// analyzeSecurityImpact analyzes the security implications of a rule.
func (a *Analyzer) analyzeSecurityImpact(rule rbacv1.PolicyRule) SecurityImpact <span class="cov3" title="2">{
        impact := SecurityImpact{
                Level:       RiskLevelLow,
                Description: "Standard resource access",
                Concerns:    []string{},
        }

        // Check for wildcards
        hasWildcardVerb := slices.Contains(rule.Verbs, "*")
        hasWildcardResource := slices.Contains(rule.Resources, "*")
        hasWildcardAPIGroup := slices.Contains(rule.APIGroups, "*")

        // Analyze risk factors
        switch </span>{
        case hasWildcardVerb &amp;&amp; hasWildcardResource &amp;&amp; hasWildcardAPIGroup:<span class="cov0" title="0">
                impact.Level = RiskLevelCritical
                impact.Description = "Complete cluster administrative access"
                impact.Concerns = append(impact.Concerns, "Can perform any action on any resource")</span>
        case hasWildcardVerb:<span class="cov0" title="0">
                impact.Level = RiskLevelHigh
                impact.Description = "Unrestricted actions on specified resources"
                impact.Concerns = append(impact.Concerns, "Can perform any action on these resources")</span>
        case hasWildcardResource:<span class="cov0" title="0">
                impact.Level = RiskLevelHigh
                impact.Description = "Access to all resources with specified permissions"
                impact.Concerns = append(impact.Concerns, "Can access any resource type")</span>
        }

        // Check for dangerous verbs
        <span class="cov3" title="2">dangerousVerbs := []string{"delete", "deletecollection", "escalate", "impersonate"}
        for _, verb := range rule.Verbs </span><span class="cov4" title="3">{
                for _, dangerous := range dangerousVerbs </span><span class="cov10" title="12">{
                        if verb == dangerous </span><span class="cov0" title="0">{
                                if impact.Level == RiskLevelLow </span><span class="cov0" title="0">{
                                        impact.Level = RiskLevelMedium
                                }</span>
                                <span class="cov0" title="0">impact.Concerns = append(impact.Concerns, fmt.Sprintf("Can %s resources", verb))</span>
                        }
                }
        }

        // Check for sensitive resources
        <span class="cov3" title="2">if a.isSensitiveResource(rule.Resources) </span><span class="cov0" title="0">{
                if impact.Level == RiskLevelLow </span><span class="cov0" title="0">{
                        impact.Level = RiskLevelMedium
                }</span>
                <span class="cov0" title="0">impact.Concerns = append(impact.Concerns, "Accesses sensitive resources")</span>
        }

        // Check for non-resource URLs
        <span class="cov3" title="2">if len(rule.NonResourceURLs) &gt; 0 </span><span class="cov0" title="0">{
                impact.Concerns = append(impact.Concerns, "Can access API endpoints directly")
        }</span>

        <span class="cov3" title="2">return impact</span>
}

// Helper functions

func (a *Analyzer) getSubjectKey(subject rbacv1.Subject) string <span class="cov6" title="5">{
        return fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Namespace, subject.Name)
}</span>

func (a *Analyzer) calculateRiskLevel(permissions []PermissionGrant) RiskLevel <span class="cov8" title="7">{
        maxRisk := RiskLevelLow

        for _, perm := range permissions </span><span class="cov7" title="6">{
                for _, rule := range perm.Rules </span><span class="cov7" title="6">{
                        if a.getRiskPriority(rule.SecurityImpact.Level) &gt; a.getRiskPriority(maxRisk) </span><span class="cov4" title="3">{
                                maxRisk = rule.SecurityImpact.Level
                        }</span>
                }
        }

        <span class="cov8" title="7">return maxRisk</span>
}

func (a *Analyzer) getRiskPriority(level RiskLevel) int <span class="cov10" title="12">{
        switch level </span>{
        case RiskLevelCritical:<span class="cov1" title="1">
                return riskPriorityCritical</span>
        case RiskLevelHigh:<span class="cov1" title="1">
                return riskPriorityHigh</span>
        case RiskLevelMedium:<span class="cov1" title="1">
                return riskPriorityMedium</span>
        case RiskLevelLow:<span class="cov8" title="9">
                return riskPriorityLow</span>
        default:<span class="cov0" title="0">
                return riskPriorityDefault</span>
        }
}

// formatAPIGroups formats API groups for human-readable output.
func (a *Analyzer) formatAPIGroups(apiGroups []string) string <span class="cov3" title="2">{
        if len(apiGroups) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov3" title="2">if len(apiGroups) == 1 &amp;&amp; apiGroups[0] == "*" </span><span class="cov0" title="0">{
                return "in ALL API groups"
        }</span>

        <span class="cov3" title="2">cleanGroups := make([]string, 0, len(apiGroups))
        for _, group := range apiGroups </span><span class="cov3" title="2">{
                if group == "" </span><span class="cov3" title="2">{
                        cleanGroups = append(cleanGroups, "core")
                }</span> else<span class="cov0" title="0"> {
                        cleanGroups = append(cleanGroups, group)
                }</span>
        }
        <span class="cov3" title="2">return fmt.Sprintf("in API groups: %s", strings.Join(cleanGroups, ", "))</span>
}

// FilterBySubject returns only the permissions for subjects matching the given name.
// If subjectName is empty, it returns an empty slice.
func FilterBySubject(permissions []SubjectPermissions, subjectName string) []SubjectPermissions <span class="cov0" title="0">{
        if subjectName == "" </span><span class="cov0" title="0">{
                return []SubjectPermissions{}
        }</span>

        <span class="cov0" title="0">var filtered []SubjectPermissions
        for _, perm := range permissions </span><span class="cov0" title="0">{
                if perm.Subject.Name == subjectName </span><span class="cov0" title="0">{
                        filtered = append(filtered, perm)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterByRiskLevel returns only the permissions matching the given risk level.
// If permissions slice is nil or empty, it returns an empty slice.
func FilterByRiskLevel(permissions []SubjectPermissions, riskLevel RiskLevel) []SubjectPermissions <span class="cov0" title="0">{
        if len(permissions) == 0 </span><span class="cov0" title="0">{
                return []SubjectPermissions{}
        }</span>

        <span class="cov0" title="0">var filtered []SubjectPermissions
        for _, perm := range permissions </span><span class="cov0" title="0">{
                if perm.RiskLevel == riskLevel </span><span class="cov0" title="0">{
                        filtered = append(filtered, perm)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package analyzer

import (
        "fmt"
        "slices"
        "sort"
        "strings"

        rbacv1 "k8s.io/api/rbac/v1"
)

// PermissionMapper provides functionality to map and search permissions.
type PermissionMapper struct {
        permissions []SubjectPermissions
}

// NewPermissionMapper returns a PermissionMapper initialized with the provided subject permissions.
func NewPermissionMapper(permissions []SubjectPermissions) *PermissionMapper <span class="cov4" title="6">{
        return &amp;PermissionMapper{
                permissions: permissions,
        }
}</span>

// WhoCanDo finds subjects that can perform a specific action on resources.
func (pm *PermissionMapper) WhoCanDo(verb, resource, apiGroup string) []PermissionMatch <span class="cov6" title="15">{
        var matches []PermissionMatch

        for _, subjectPerm := range pm.permissions </span><span class="cov8" title="30">{
                for _, perm := range subjectPerm.Permissions </span><span class="cov8" title="30">{
                        for _, rule := range perm.Rules </span><span class="cov8" title="30">{
                                if pm.ruleMatches(rule, verb, resource, apiGroup) </span><span class="cov5" title="10">{
                                        matches = append(matches, PermissionMatch{
                                                Subject:     pm.convertSubject(subjectPerm.Subject),
                                                Permission:  perm,
                                                Rule:        rule,
                                                MatchReason: pm.getMatchReason(rule, verb, resource, apiGroup),
                                        })
                                }</span>
                        }
                }
        }

        // Sort by risk level (highest first)
        <span class="cov6" title="15">sort.Slice(matches, func(i, j int) bool </span><span class="cov1" title="1">{
                return pm.getRiskPriority(matches[i].Rule.SecurityImpact.Level) &gt;
                        pm.getRiskPriority(matches[j].Rule.SecurityImpact.Level)
        }</span>)

        <span class="cov6" title="15">return matches</span>
}

// WhatCanSubjectDo returns all permissions for a specific subject.
func (pm *PermissionMapper) WhatCanSubjectDo(subjectKind, subjectName string) []SubjectPermissions <span class="cov3" title="4">{
        var matches []SubjectPermissions

        for _, subjectPerm := range pm.permissions </span><span class="cov6" title="12">{
                if (subjectKind == "" || subjectPerm.Subject.Kind == subjectKind) &amp;&amp;
                        (subjectName == "" || subjectPerm.Subject.Name == subjectName) </span><span class="cov3" title="4">{
                        matches = append(matches, subjectPerm)
                }</span>
        }

        <span class="cov3" title="4">return matches</span>
}

// GetDangerousPermissions returns subjects with high-risk permissions.
func (pm *PermissionMapper) GetDangerousPermissions() []DangerousPermission <span class="cov1" title="1">{
        var dangerous []DangerousPermission

        for _, subjectPerm := range pm.permissions </span><span class="cov2" title="2">{
                for _, perm := range subjectPerm.Permissions </span><span class="cov3" title="3">{
                        for _, rule := range perm.Rules </span><span class="cov3" title="3">{
                                if rule.SecurityImpact.Level == RiskLevelHigh ||
                                        rule.SecurityImpact.Level == RiskLevelCritical </span><span class="cov2" title="2">{
                                        dangerous = append(dangerous, DangerousPermission{
                                                Subject:     pm.convertSubject(subjectPerm.Subject),
                                                Permission:  perm,
                                                Rule:        rule,
                                                RiskLevel:   rule.SecurityImpact.Level,
                                                Explanation: rule.SecurityImpact.Description,
                                                Concerns:    rule.SecurityImpact.Concerns,
                                        })
                                }</span>
                        }
                }
        }

        // Sort by risk level
        <span class="cov1" title="1">sort.Slice(dangerous, func(i, j int) bool </span><span class="cov1" title="1">{
                return pm.getRiskPriority(dangerous[i].RiskLevel) &gt;
                        pm.getRiskPriority(dangerous[j].RiskLevel)
        }</span>)

        <span class="cov1" title="1">return dangerous</span>
}

// GetPrivilegeEscalationPaths finds potential privilege escalation paths.
func (pm *PermissionMapper) GetPrivilegeEscalationPaths() []EscalationPath <span class="cov1" title="1">{
        var paths []EscalationPath

        for _, subjectPerm := range pm.permissions </span><span class="cov3" title="3">{
                escalationRisks := pm.analyzeEscalationRisk(subjectPerm)
                if len(escalationRisks) &gt; 0 </span><span class="cov2" title="2">{
                        paths = append(paths, EscalationPath{
                                Subject: pm.convertSubject(subjectPerm.Subject),
                                Risks:   escalationRisks,
                        })
                }</span>
        }

        <span class="cov1" title="1">return paths</span>
}

// GetResourceAccess shows who has access to specific resources.
func (pm *PermissionMapper) GetResourceAccess(resource, apiGroup string) ResourceAccessMap <span class="cov1" title="1">{
        accessMap := ResourceAccessMap{
                Resource: resource,
                APIGroup: apiGroup,
                Access:   make(map[string][]ResourceAccess),
        }

        verbs := []string{
                "get",
                "list",
                "watch",
                "create",
                "update",
                "patch",
                "delete",
                "bind",
                "escalate",
                "impersonate",
                "*",
        }

        for _, verb := range verbs </span><span class="cov6" title="11">{
                matches := pm.WhoCanDo(verb, resource, apiGroup)
                for _, match := range matches </span><span class="cov4" title="5">{
                        accessMap.Access[verb] = append(accessMap.Access[verb], ResourceAccess{
                                Subject:    match.Subject,
                                Permission: match.Permission,
                                RiskLevel:  match.Rule.SecurityImpact.Level,
                        })
                }</span>
        }

        <span class="cov1" title="1">return accessMap</span>
}

// Helper methods

func (pm *PermissionMapper) ruleMatches(rule PolicyRuleAnalysis, verb, resource, apiGroup string) bool <span class="cov8" title="37">{
        // Check verbs
        if !pm.matchesVerb(rule.Verbs, verb) </span><span class="cov7" title="21">{
                return false
        }</span>

        // Check resources
        <span class="cov6" title="16">if !pm.matchesResource(rule.Resources, resource) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check API groups
        <span class="cov6" title="15">if !pm.matchesAPIGroup(rule.APIGroups, apiGroup) </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov6" title="14">return true</span>
}

func (pm *PermissionMapper) matchesVerb(ruleVerbs []string, targetVerb string) bool <span class="cov8" title="37">{
        for _, verb := range ruleVerbs </span><span class="cov10" title="70">{
                if verb == "*" || verb == targetVerb </span><span class="cov6" title="16">{
                        return true
                }</span>
        }
        <span class="cov7" title="21">return false</span>
}

func (pm *PermissionMapper) matchesResource(ruleResources []string, targetResource string) bool <span class="cov7" title="21">{
        for _, resource := range ruleResources </span><span class="cov7" title="22">{
                if resource == "*" || resource == targetResource </span><span class="cov7" title="17">{
                        return true
                }</span>
                // Handle subresources (e.g., pods/exec matches pods)
                <span class="cov4" title="5">if strings.Contains(targetResource, "/") </span><span class="cov2" title="2">{
                        parts := strings.Split(targetResource, "/")
                        if resource == parts[0] </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov3" title="3">return false</span>
}

func (pm *PermissionMapper) matchesAPIGroup(ruleAPIGroups []string, targetAPIGroup string) bool <span class="cov7" title="20">{
        for _, apiGroup := range ruleAPIGroups </span><span class="cov7" title="20">{
                if apiGroup == "*" || apiGroup == targetAPIGroup </span><span class="cov6" title="16">{
                        return true
                }</span>
                // Empty string in rule matches core API group
                <span class="cov3" title="4">if apiGroup == "" &amp;&amp; targetAPIGroup == "core" </span><span class="cov1" title="1">{
                        return true
                }</span>
                // Core API group in rule matches empty string target
                <span class="cov3" title="3">if apiGroup == "core" &amp;&amp; targetAPIGroup == "" </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

func (pm *PermissionMapper) getMatchReason(rule PolicyRuleAnalysis, verb, resource, apiGroup string) string <span class="cov6" title="14">{
        var reasons []string

        // Check if wildcard matches
        if slices.Contains(rule.Verbs, "*") </span><span class="cov4" title="5">{
                reasons = append(reasons, fmt.Sprintf("wildcard verb permission (requested: %s)", verb))
        }</span>

        <span class="cov6" title="14">if slices.Contains(rule.Resources, "*") </span><span class="cov4" title="5">{
                reasons = append(reasons, fmt.Sprintf("wildcard resource permission (requested: %s)", resource))
        }</span>

        <span class="cov6" title="14">if slices.Contains(rule.APIGroups, "*") </span><span class="cov4" title="5">{
                reasons = append(reasons, fmt.Sprintf("wildcard API group permission (requested: %s)", apiGroup))
        }</span>

        <span class="cov6" title="14">if len(reasons) == 0 </span><span class="cov5" title="7">{
                // Build explicit match reason showing what matched
                matchDetails := []string{}
                if verb != "" </span><span class="cov5" title="7">{
                        matchDetails = append(matchDetails, fmt.Sprintf("verb=%s", verb))
                }</span>
                <span class="cov5" title="7">if resource != "" </span><span class="cov5" title="7">{
                        matchDetails = append(matchDetails, fmt.Sprintf("resource=%s", resource))
                }</span>
                <span class="cov5" title="7">if apiGroup != "" </span><span class="cov0" title="0">{
                        matchDetails = append(matchDetails, fmt.Sprintf("apiGroup=%s", apiGroup))
                }</span>
                <span class="cov5" title="7">reasons = append(reasons, fmt.Sprintf("explicit permission match (%s)", strings.Join(matchDetails, ", ")))</span>
        }

        <span class="cov6" title="14">return strings.Join(reasons, ", ")</span>
}

//nolint:gocognit // Escalation risk analysis requires complex logic
func (pm *PermissionMapper) analyzeEscalationRisk(subjectPerm SubjectPermissions) []EscalationRisk <span class="cov5" title="9">{
        var risks []EscalationRisk

        for _, perm := range subjectPerm.Permissions </span><span class="cov5" title="9">{
                for _, rule := range perm.Rules </span><span class="cov5" title="10">{
                        // Check for escalate verb
                        for _, verb := range rule.Verbs </span><span class="cov6" title="12">{
                                if verb == "escalate" </span><span class="cov2" title="2">{
                                        risks = append(risks, EscalationRisk{
                                                Type:        "Privilege Escalation",
                                                Description: "Can escalate privileges through RBAC",
                                                Severity:    RiskLevelCritical,
                                                Rule:        rule,
                                        })
                                }</span>

                                <span class="cov6" title="12">if verb == "impersonate" </span><span class="cov3" title="3">{
                                        risks = append(risks, EscalationRisk{
                                                Type:        "Identity Impersonation",
                                                Description: "Can impersonate other users or service accounts",
                                                Severity:    RiskLevelCritical,
                                                Rule:        rule,
                                        })
                                }</span>

                                <span class="cov6" title="12">if verb == "*" </span><span class="cov2" title="2">{
                                        risks = append(risks, EscalationRisk{
                                                Type:        "Unrestricted Access",
                                                Description: "Has wildcard permissions on resources",
                                                Severity:    RiskLevelHigh,
                                                Rule:        rule,
                                        })
                                }</span>
                        }

                        // Check for dangerous resource combinations
                        <span class="cov5" title="10">hasSecretsAccess := false
                        hasRBACAccess := false

                        for _, resource := range rule.Resources </span><span class="cov6" title="11">{
                                if resource == "secrets" || resource == "*" </span><span class="cov2" title="2">{
                                        hasSecretsAccess = true
                                }</span>
                                // Explicitly match known RBAC resource names including cluster-scoped
                                <span class="cov6" title="11">if resource == "role" || resource == "roles" ||
                                        resource == "rolebinding" || resource == "rolebindings" ||
                                        resource == "clusterrole" || resource == "clusterroles" ||
                                        resource == "clusterrolebinding" || resource == "clusterrolebindings" ||
                                        resource == "*" </span><span class="cov3" title="4">{
                                        hasRBACAccess = true
                                }</span>
                        }

                        <span class="cov5" title="10">if hasSecretsAccess &amp;&amp; hasRBACAccess </span><span class="cov2" title="2">{
                                risks = append(risks, EscalationRisk{
                                        Type:        "Secrets + RBAC Access",
                                        Description: "Can access secrets and modify RBAC - potential for privilege escalation",
                                        Severity:    RiskLevelHigh,
                                        Rule:        rule,
                                })
                        }</span>
                }
        }

        <span class="cov5" title="9">return risks</span>
}

func (pm *PermissionMapper) getRiskPriority(level RiskLevel) int <span class="cov5" title="9">{
        switch level </span>{
        case RiskLevelCritical:<span class="cov3" title="3">
                return riskPriorityCritical</span>
        case RiskLevelHigh:<span class="cov2" title="2">
                return riskPriorityHigh</span>
        case RiskLevelMedium:<span class="cov1" title="1">
                return riskPriorityMedium</span>
        case RiskLevelLow:<span class="cov2" title="2">
                return riskPriorityLow</span>
        default:<span class="cov1" title="1">
                return riskPriorityDefault</span>
        }
}

func (pm *PermissionMapper) convertSubject(subject rbacv1.Subject) SubjectRef <span class="cov6" title="15">{
        return SubjectRef{
                Kind:      subject.Kind,
                Name:      subject.Name,
                Namespace: subject.Namespace,
        }
}</span>

// Data structures for mapping results

// PermissionMatch represents a subject that matches a permission query.
type PermissionMatch struct {
        Subject     SubjectRef         `json:"subject"`
        Permission  PermissionGrant    `json:"permission"`
        Rule        PolicyRuleAnalysis `json:"rule"`
        MatchReason string             `json:"match_reason"`
}

// DangerousPermission represents a high-risk permission.
type DangerousPermission struct {
        Subject     SubjectRef         `json:"subject"`
        Permission  PermissionGrant    `json:"permission"`
        Rule        PolicyRuleAnalysis `json:"rule"`
        RiskLevel   RiskLevel          `json:"risk_level"`
        Explanation string             `json:"explanation"`
        Concerns    []string           `json:"concerns"`
}

// EscalationPath represents potential privilege escalation.
type EscalationPath struct {
        Subject SubjectRef       `json:"subject"`
        Risks   []EscalationRisk `json:"risks"`
}

// EscalationRisk represents a specific escalation risk.
type EscalationRisk struct {
        Type        string             `json:"type"`
        Description string             `json:"description"`
        Severity    RiskLevel          `json:"severity"`
        Rule        PolicyRuleAnalysis `json:"rule"`
}

// ResourceAccessMap shows who can access a resource.
type ResourceAccessMap struct {
        Resource string                      `json:"resource"`
        APIGroup string                      `json:"api_group"`
        Access   map[string][]ResourceAccess `json:"access"`
}

// ResourceAccess represents access to a resource.
type ResourceAccess struct {
        Subject    SubjectRef      `json:"subject"`
        Permission PermissionGrant `json:"permission"`
        RiskLevel  RiskLevel       `json:"risk_level"`
}

// SubjectRef is a simplified subject reference.
type SubjectRef struct {
        Kind      string `json:"kind"`
        Name      string `json:"name"`
        Namespace string `json:"namespace,omitempty"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package kubernetes

import (
        "context"
        "fmt"

        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"

        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        rbacv1client "k8s.io/client-go/kubernetes/typed/rbac/v1"
)

// RBACReader provides read-only access to RBAC resources.
type RBACReader interface {
        // Roles returns a read-only interface for roles
        Roles(namespace string) rbacv1client.RoleInterface
        // RoleBindings returns a read-only interface for role bindings
        RoleBindings(namespace string) rbacv1client.RoleBindingInterface
        // ClusterRoles returns a read-only interface for cluster roles
        ClusterRoles() rbacv1client.ClusterRoleInterface
        // ClusterRoleBindings returns a read-only interface for cluster role bindings
        ClusterRoleBindings() rbacv1client.ClusterRoleBindingInterface
}

// rbacReaderImpl implements the RBACReader interface.
type rbacReaderImpl struct {
        rbacClient rbacv1client.RbacV1Interface
}

func (r *rbacReaderImpl) Roles(namespace string) rbacv1client.RoleInterface <span class="cov5" title="2">{
        return r.rbacClient.Roles(namespace)
}</span>

func (r *rbacReaderImpl) RoleBindings(namespace string) rbacv1client.RoleBindingInterface <span class="cov5" title="2">{
        return r.rbacClient.RoleBindings(namespace)
}</span>

func (r *rbacReaderImpl) ClusterRoles() rbacv1client.ClusterRoleInterface <span class="cov5" title="2">{
        return r.rbacClient.ClusterRoles()
}</span>

func (r *rbacReaderImpl) ClusterRoleBindings() rbacv1client.ClusterRoleBindingInterface <span class="cov5" title="2">{
        return r.rbacClient.ClusterRoleBindings()
}</span>

// Client provides methods to fetch RBAC resources from a Kubernetes cluster.
type Client struct {
        clientset kubernetes.Interface
}

// NewClient creates a new Client for interacting with a Kubernetes cluster using the specified kubeconfig file and context name.
// Returns an error if the configuration cannot be loaded or the client cannot be created.
func NewClient(kubeconfig string, contextName string) (*Client, error) <span class="cov0" title="0">{
        config, err := getConfigWithContext(kubeconfig, contextName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get kubernetes config: %w", err)
        }</span>
        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                clientset: clientset,
        }, nil</span>
}

// NewClientFromConfig returns a new Client using the provided Kubernetes REST configuration.
// Returns an error if the clientset cannot be created.
func NewClientFromConfig(config *rest.Config) (*Client, error) <span class="cov1" title="1">{
        clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;Client{
                clientset: clientset,
        }, nil</span>
}

// GetRBACReader returns a read-only interface for RBAC operations.
func (c *Client) GetRBACReader() RBACReader <span class="cov1" title="1">{
        return &amp;rbacReaderImpl{
                rbacClient: c.clientset.RbacV1(),
        }
}</span>

// getConfigWithContext loads a Kubernetes REST config from the specified kubeconfig file, optionally overriding the current context.
// Returns the configured *rest.Config or an error if loading fails.
func getConfigWithContext(kubeconfig, contextName string) (*rest.Config, error) <span class="cov0" title="0">{
        loadingRules := &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfig}

        configOverrides := &amp;clientcmd.ConfigOverrides{}
        if contextName != "" </span><span class="cov0" title="0">{
                configOverrides.CurrentContext = contextName
        }</span>
        <span class="cov0" title="0">clientConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        return clientConfig.ClientConfig()</span>
}

// FetchAllRBACResources fetches all RBAC resources from the cluster.
func (c *Client) FetchAllRBACResources(ctx context.Context) ([]runtime.Object, error) <span class="cov1" title="1">{
        var resources []runtime.Object

        // Fetch Roles
        roles, err := c.FetchRoles(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch roles: %w", err)
        }</span>
        <span class="cov1" title="1">resources = append(resources, roles...)

        // Fetch RoleBindings
        roleBindings, err := c.FetchRoleBindings(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch role bindings: %w", err)
        }</span>
        <span class="cov1" title="1">resources = append(resources, roleBindings...)

        // Fetch ClusterRoles
        clusterRoles, err := c.FetchClusterRoles(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch cluster roles: %w", err)
        }</span>
        <span class="cov1" title="1">resources = append(resources, clusterRoles...)

        // Fetch ClusterRoleBindings
        clusterRoleBindings, err := c.FetchClusterRoleBindings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch cluster role bindings: %w", err)
        }</span>
        <span class="cov1" title="1">resources = append(resources, clusterRoleBindings...)

        return resources, nil</span>
}

// FetchRoles fetches roles from a namespace (or all namespaces if namespace is empty).
func (c *Client) FetchRoles(ctx context.Context, namespace string) ([]runtime.Object, error) <span class="cov10" title="4">{
        var resources []runtime.Object

        roleList, err := c.clientset.RbacV1().
                Roles(namespace).
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="4">for i := range roleList.Items </span><span class="cov10" title="4">{
                resources = append(resources, &amp;roleList.Items[i])
        }</span>

        <span class="cov10" title="4">return resources, nil</span>
}

// FetchRoleBindings fetches role bindings from a namespace (or all namespaces if namespace is empty).
func (c *Client) FetchRoleBindings(ctx context.Context, namespace string) ([]runtime.Object, error) <span class="cov8" title="3">{
        var resources []runtime.Object

        roleBindingList, err := c.clientset.RbacV1().
                RoleBindings(namespace).
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">for i := range roleBindingList.Items </span><span class="cov10" title="4">{
                resources = append(resources, &amp;roleBindingList.Items[i])
        }</span>

        <span class="cov8" title="3">return resources, nil</span>
}

// FetchClusterRoles fetches all cluster roles.
func (c *Client) FetchClusterRoles(ctx context.Context) ([]runtime.Object, error) <span class="cov5" title="2">{
        var resources []runtime.Object

        clusterRoleList, err := c.clientset.RbacV1().
                ClusterRoles().
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">for i := range clusterRoleList.Items </span><span class="cov8" title="3">{
                resources = append(resources, &amp;clusterRoleList.Items[i])
        }</span>

        <span class="cov5" title="2">return resources, nil</span>
}

// FetchClusterRoleBindings fetches all cluster role bindings.
func (c *Client) FetchClusterRoleBindings(ctx context.Context) ([]runtime.Object, error) <span class="cov5" title="2">{
        var resources []runtime.Object

        clusterRoleBindingList, err := c.clientset.RbacV1().
                ClusterRoleBindings().
                List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">for i := range clusterRoleBindingList.Items </span><span class="cov8" title="3">{
                resources = append(resources, &amp;clusterRoleBindingList.Items[i])
        }</span>

        <span class="cov5" title="2">return resources, nil</span>
}

// FetchSpecificRole fetches a specific role.
func (c *Client) FetchSpecificRole(ctx context.Context, namespace, name string) (*rbacv1.Role, error) <span class="cov5" title="2">{
        return c.clientset.RbacV1().
                Roles(namespace).
                Get(ctx, name, metav1.GetOptions{})
}</span>

// FetchSpecificRoleBinding fetches a specific role binding.
func (c *Client) FetchSpecificRoleBinding(ctx context.Context, namespace, name string) (*rbacv1.RoleBinding, error) <span class="cov1" title="1">{
        return c.clientset.RbacV1().
                RoleBindings(namespace).
                Get(ctx, name, metav1.GetOptions{})
}</span>

// FetchSpecificClusterRole fetches a specific cluster role.
func (c *Client) FetchSpecificClusterRole(ctx context.Context, name string) (*rbacv1.ClusterRole, error) <span class="cov1" title="1">{
        return c.clientset.RbacV1().
                ClusterRoles().
                Get(ctx, name, metav1.GetOptions{})
}</span>

// FetchSpecificClusterRoleBinding fetches a specific cluster role binding.
func (c *Client) FetchSpecificClusterRoleBinding(ctx context.Context, name string) (*rbacv1.ClusterRoleBinding, error) <span class="cov1" title="1">{
        return c.clientset.RbacV1().
                ClusterRoleBindings().
                Get(ctx, name, metav1.GetOptions{})
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package kubernetes

import (
        "fmt"

        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
)

// loadKubeConfig loads a Kubernetes kubeconfig file from the specified path or the default location if no path is provided.
// It returns the parsed configuration object or an error if loading fails.
func loadKubeConfig(kubeconfig string) (*api.Config, error) <span class="cov0" title="0">{
        configAccess := clientcmd.NewDefaultPathOptions()
        if kubeconfig != "" </span><span class="cov0" title="0">{
                configAccess.GlobalFile = kubeconfig
        }</span>
        <span class="cov0" title="0">return configAccess.GetStartingConfig()</span>
}

// GetAvailableContexts retrieves the names of all contexts defined in the specified kubeconfig file.
// Returns a slice of context names or an error if the kubeconfig cannot be loaded.
func GetAvailableContexts(kubeconfig string) ([]string, error) <span class="cov0" title="0">{
        config, err := loadKubeConfig(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">contexts := make([]string, 0, len(config.Contexts))
        for name := range config.Contexts </span><span class="cov0" title="0">{
                contexts = append(contexts, name)
        }</span>
        <span class="cov0" title="0">return contexts, nil</span>
}

// BuildConfigWithContext loads a kubeconfig file and sets the current context to the specified value if provided.
// Returns the loaded config with the current context set, or an error if loading fails or the context does not exist.
func BuildConfigWithContext(kubeconfig, context string) (*api.Config, error) <span class="cov0" title="0">{
        config, err := loadKubeConfig(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if context != "" </span><span class="cov0" title="0">{
                if _, ok := config.Contexts[context]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("context '%s' not found in kubeconfig", context)
                }</span>
                <span class="cov0" title="0">config.CurrentContext = context</span>
        }
        <span class="cov0" title="0">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package parser

import (
        "errors"
        "fmt"
        "io"
        "os"

        "gopkg.in/yaml.v3"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/runtime/serializer"

        rbacv1 "k8s.io/api/rbac/v1"
)

// Parser handles parsing of Kubernetes RBAC YAML manifests.
type Parser struct {
        decoder runtime.Decoder
}

// New creates a new Parser instance.
func New() *Parser <span class="cov8" title="14">{
        scheme := runtime.NewScheme()
        _ = rbacv1.AddToScheme(scheme)

        codecFactory := serializer.NewCodecFactory(scheme)
        decoder := codecFactory.UniversalDeserializer()

        return &amp;Parser{
                decoder: decoder,
        }
}</span>

// ParseFile parses a single RBAC YAML file.
func (p *Parser) ParseFile(filename string) ([]runtime.Object, error) <span class="cov2" title="2">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        return p.Parse(file)</span>
}

// Parse parses RBAC YAML from a reader.
func (p *Parser) Parse(reader io.Reader) ([]runtime.Object, error) <span class="cov7" title="12">{
        var objects []runtime.Object

        decoder := yaml.NewDecoder(reader)
        for </span><span class="cov10" title="27">{
                var doc interface{}
                err := decoder.Decode(&amp;doc)
                if errors.Is(err, io.EOF) </span><span class="cov7" title="10">{
                        break</span>
                }
                <span class="cov8" title="17">if err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("failed to decode YAML: %w", err)
                }</span>

                // Skip empty documents
                <span class="cov8" title="15">if doc == nil </span><span class="cov4" title="3">{
                        continue</span>
                }

                // Convert back to YAML bytes for k8s decoder
                <span class="cov7" title="12">yamlBytes, err := yaml.Marshal(doc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal YAML: %w", err)
                }</span>

                <span class="cov7" title="12">obj, gvk, err := p.decoder.Decode(yamlBytes, nil, nil)
                if err != nil </span><span class="cov2" title="2">{
                        // Skip non-RBAC resources
                        continue</span>
                }

                // Only process RBAC resources
                <span class="cov7" title="10">if gvk.Group == "rbac.authorization.k8s.io" </span><span class="cov7" title="10">{
                        objects = append(objects, obj)
                }</span>
        }

        <span class="cov7" title="10">return objects, nil</span>
}

// GetObjectKind returns the kind of the runtime object.
func GetObjectKind(obj runtime.Object) string <span class="cov5" title="5">{
        switch obj.(type) </span>{
        case *rbacv1.Role:<span class="cov1" title="1">
                return "Role"</span>
        case *rbacv1.RoleBinding:<span class="cov1" title="1">
                return "RoleBinding"</span>
        case *rbacv1.ClusterRole:<span class="cov1" title="1">
                return "ClusterRole"</span>
        case *rbacv1.ClusterRoleBinding:<span class="cov1" title="1">
                return "ClusterRoleBinding"</span>
        default:<span class="cov1" title="1">
                return "Unknown"</span>
        }
}

// GetObjectGVK returns the GroupVersionKind of the runtime object.
func GetObjectGVK(obj runtime.Object) schema.GroupVersionKind <span class="cov5" title="5">{
        switch obj.(type) </span>{
        case *rbacv1.Role:<span class="cov1" title="1">
                return rbacv1.SchemeGroupVersion.WithKind("Role")</span>
        case *rbacv1.RoleBinding:<span class="cov1" title="1">
                return rbacv1.SchemeGroupVersion.WithKind("RoleBinding")</span>
        case *rbacv1.ClusterRole:<span class="cov1" title="1">
                return rbacv1.SchemeGroupVersion.WithKind("ClusterRole")</span>
        case *rbacv1.ClusterRoleBinding:<span class="cov1" title="1">
                return rbacv1.SchemeGroupVersion.WithKind("ClusterRoleBinding")</span>
        default:<span class="cov1" title="1">
                return schema.GroupVersionKind{}</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package reporter

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/coolguy1771/guardrail/pkg/validator"
)

const (
        // Formatting constants.
        tabwriterPadding = 2
        separatorLength  = 80
)

// Reporter handles output formatting for validation findings.
type Reporter interface {
        Report(findings []validator.Finding, writer io.Writer) error
}

// Format represents the output format.
type Format string

const (
        FormatText  Format = "text"
        FormatJSON  Format = "json"
        FormatSARIF Format = "sarif"
)

// New creates a new reporter based on the specified format.
func New(format Format) Reporter <span class="cov5" title="5">{
        switch format </span>{
        case FormatJSON:<span class="cov3" title="2">
                return &amp;JSONReporter{}</span>
        case FormatSARIF:<span class="cov1" title="1">
                return &amp;SARIFReporter{}</span>
        case FormatText:<span class="cov1" title="1">
                return &amp;TextReporter{}</span>
        default:<span class="cov1" title="1">
                return &amp;TextReporter{}</span>
        }
}

// TextReporter outputs findings in human-readable text format.
type TextReporter struct{}

// Report outputs findings in text format.
func (r *TextReporter) Report(findings []validator.Finding, writer io.Writer) error <span class="cov4" title="3">{
        if len(findings) == 0 </span><span class="cov1" title="1">{
                fmt.Fprintln(writer, "‚úÖ No issues found!")
                return nil
        }</span>

        // Group findings by severity
        <span class="cov3" title="2">grouped := groupBySeverity(findings)

        // Summary
        fmt.Fprintf(writer, "Found %d issue(s)\n\n", len(findings))

        // Create a tabwriter for aligned output
        w := tabwriter.NewWriter(writer, 0, 0, tabwriterPadding, ' ', 0)
        defer w.Flush()

        // Output findings by severity
        for _, severity := range []validator.Severity{
                validator.SeverityHigh,
                validator.SeverityMedium,
                validator.SeverityLow,
                validator.SeverityInfo,
        } </span><span class="cov7" title="8">{
                if severityFindings, ok := grouped[severity]; ok </span><span class="cov5" title="5">{
                        fmt.Fprintf(w, "%s %s (%d)\n", getSeverityIcon(severity), severity, len(severityFindings))
                        fmt.Fprintln(w, strings.Repeat("-", separatorLength))

                        for _, finding := range severityFindings </span><span class="cov6" title="6">{
                                fmt.Fprintf(w, "Rule:\t%s - %s\n", finding.RuleID, finding.RuleName)
                                fmt.Fprintf(w, "Resource:\t%s/%s", finding.Kind, finding.Resource)
                                if finding.Namespace != "" </span><span class="cov4" title="3">{
                                        fmt.Fprintf(w, " (namespace: %s)", finding.Namespace)
                                }</span>
                                <span class="cov6" title="6">fmt.Fprintln(w)
                                fmt.Fprintf(w, "Message:\t%s\n", finding.Message)
                                if finding.Remediation != "" </span><span class="cov5" title="4">{
                                        fmt.Fprintf(w, "Remediation:\t%s\n", finding.Remediation)
                                }</span>
                                <span class="cov6" title="6">fmt.Fprintln(w)</span>
                        }
                }
        }

        <span class="cov3" title="2">return nil</span>
}

// JSONReporter outputs findings in JSON format.
type JSONReporter struct{}

// JSONReport represents the JSON output structure.
type JSONReport struct {
        Timestamp string              `json:"timestamp"`
        Summary   Summary             `json:"summary"`
        Findings  []validator.Finding `json:"findings"`
}

// Summary represents the summary of findings.
type Summary struct {
        Total      int            `json:"total"`
        BySeverity map[string]int `json:"by_severity"`
}

// Report outputs findings in JSON format.
func (r *JSONReporter) Report(findings []validator.Finding, writer io.Writer) error <span class="cov5" title="4">{
        grouped := groupBySeverity(findings)
        bySeverity := make(map[string]int)

        for severity, severityFindings := range grouped </span><span class="cov7" title="9">{
                bySeverity[string(severity)] = len(severityFindings)
        }</span>

        <span class="cov5" title="4">report := JSONReport{
                Timestamp: time.Now().UTC().Format(time.RFC3339),
                Summary: Summary{
                        Total:      len(findings),
                        BySeverity: bySeverity,
                },
                Findings: findings,
        }

        encoder := json.NewEncoder(writer)
        encoder.SetIndent("", "  ")
        return encoder.Encode(report)</span> //nolint:musttag // JSONReport struct has proper json tags
}

// SARIFReporter outputs findings in SARIF format.
type SARIFReporter struct{}

// SARIF structures.
type SARIF struct {
        Version string     `json:"version"`
        Schema  string     `json:"$schema"`
        Runs    []SARIFRun `json:"runs"`
}

type SARIFRun struct {
        Tool    SARIFTool     `json:"tool"`
        Results []SARIFResult `json:"results"`
}

type SARIFTool struct {
        Driver SARIFDriver `json:"driver"`
}

type SARIFDriver struct {
        Name           string      `json:"name"`
        Version        string      `json:"version"`
        InformationURI string      `json:"informationUri"`
        Rules          []SARIFRule `json:"rules"`
}

type SARIFRule struct {
        ID                   string                 `json:"id"`
        Name                 string                 `json:"name"`
        ShortDescription     SARIFMultiformatString `json:"shortDescription"`
        FullDescription      SARIFMultiformatString `json:"fullDescription"`
        DefaultConfiguration SARIFConfiguration     `json:"defaultConfiguration"`
}

type SARIFMultiformatString struct {
        Text string `json:"text"`
}

type SARIFConfiguration struct {
        Level string `json:"level"`
}

type SARIFResult struct {
        RuleID    string          `json:"ruleId"`
        Level     string          `json:"level"`
        Message   SARIFMessage    `json:"message"`
        Locations []SARIFLocation `json:"locations"`
}

type SARIFMessage struct {
        Text string `json:"text"`
}

type SARIFLocation struct {
        PhysicalLocation SARIFPhysicalLocation `json:"physicalLocation"`
}

type SARIFPhysicalLocation struct {
        ArtifactLocation SARIFArtifactLocation `json:"artifactLocation"`
}

type SARIFArtifactLocation struct {
        URI string `json:"uri"`
}

// Report outputs findings in SARIF format.
func (r *SARIFReporter) Report(findings []validator.Finding, writer io.Writer) error <span class="cov1" title="1">{
        // Build rules from findings
        rulesMap := make(map[string]SARIFRule)
        for _, finding := range findings </span><span class="cov5" title="5">{
                if _, exists := rulesMap[finding.RuleID]; !exists </span><span class="cov5" title="5">{
                        rulesMap[finding.RuleID] = SARIFRule{
                                ID:   finding.RuleID,
                                Name: finding.RuleName,
                                ShortDescription: SARIFMultiformatString{
                                        Text: finding.RuleName,
                                },
                                FullDescription: SARIFMultiformatString{
                                        Text: finding.RuleName,
                                },
                                DefaultConfiguration: SARIFConfiguration{
                                        Level: severityToSARIFLevel(finding.Severity),
                                },
                        }
                }</span>
        }

        // Convert map to slice
        <span class="cov1" title="1">var rules []SARIFRule
        for _, rule := range rulesMap </span><span class="cov5" title="5">{
                rules = append(rules, rule)
        }</span>
        <span class="cov1" title="1">sort.Slice(rules, func(i, j int) bool </span><span class="cov5" title="4">{
                return rules[i].ID &lt; rules[j].ID
        }</span>)

        // Build results
        <span class="cov1" title="1">var results []SARIFResult
        for _, finding := range findings </span><span class="cov5" title="5">{
                uri := fmt.Sprintf("%s/%s", finding.Kind, finding.Resource)
                if finding.Namespace != "" </span><span class="cov4" title="3">{
                        uri = fmt.Sprintf("namespace/%s/%s", finding.Namespace, uri)
                }</span>

                <span class="cov5" title="5">results = append(results, SARIFResult{
                        RuleID: finding.RuleID,
                        Level:  severityToSARIFLevel(finding.Severity),
                        Message: SARIFMessage{
                                Text: finding.Message,
                        },
                        Locations: []SARIFLocation{
                                {
                                        PhysicalLocation: SARIFPhysicalLocation{
                                                ArtifactLocation: SARIFArtifactLocation{
                                                        URI: uri,
                                                },
                                        },
                                },
                        },
                })</span>
        }

        <span class="cov1" title="1">sarif := SARIF{
                Version: "2.1.0",
                Schema:  "https://json.schemastore.org/sarif-2.1.0.json",
                Runs: []SARIFRun{
                        {
                                Tool: SARIFTool{
                                        Driver: SARIFDriver{
                                                Name:           "guardrail",
                                                Version:        "1.0.0",
                                                InformationURI: "https://github.com/coolguy1771/guardrail",
                                                Rules:          rules,
                                        },
                                },
                                Results: results,
                        },
                },
        }

        encoder := json.NewEncoder(writer)
        encoder.SetIndent("", "  ")
        return encoder.Encode(sarif)</span>
}

// Helper functions

func groupBySeverity(findings []validator.Finding) map[validator.Severity][]validator.Finding <span class="cov6" title="7">{
        grouped := make(map[validator.Severity][]validator.Finding)
        for _, finding := range findings </span><span class="cov10" title="22">{
                grouped[finding.Severity] = append(grouped[finding.Severity], finding)
        }</span>
        <span class="cov6" title="7">return grouped</span>
}

func getSeverityIcon(severity validator.Severity) string <span class="cov7" title="10">{
        switch severity </span>{
        case validator.SeverityHigh:<span class="cov4" title="3">
                return "üî¥"</span>
        case validator.SeverityMedium:<span class="cov3" title="2">
                return "üü°"</span>
        case validator.SeverityLow:<span class="cov3" title="2">
                return "üîµ"</span>
        case validator.SeverityInfo:<span class="cov3" title="2">
                return "‚ÑπÔ∏è"</span>
        default:<span class="cov1" title="1">
                return "‚Ä¢"</span>
        }
}

func severityToSARIFLevel(severity validator.Severity) string <span class="cov8" title="15">{
        switch severity </span>{
        case validator.SeverityHigh:<span class="cov5" title="5">
                return "error"</span>
        case validator.SeverityMedium:<span class="cov4" title="3">
                return "warning"</span>
        case validator.SeverityLow:<span class="cov4" title="3">
                return "note"</span>
        case validator.SeverityInfo:<span class="cov4" title="3">
                return "note"</span>
        default:<span class="cov1" title="1">
                return "none"</span>
        }
}

// ReportToFile writes the report to a file.
func ReportToFile(findings []validator.Finding, format Format, filename string) error <span class="cov3" title="2">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        reporter := New(format)
        return reporter.Report(findings, file)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package validator

import (
        "fmt"
        "slices"

        "k8s.io/apimachinery/pkg/runtime"

        rbacv1 "k8s.io/api/rbac/v1"
)

// Common verb constants.
const (
        verbCreate = "create"
        verbUpdate = "update"
        verbPatch  = "patch"
        verbDelete = "delete"
        verbAll    = "*"
)

// Common RBAC kind constants.
const (
        kindClusterRole = "ClusterRole"
)

// validateServiceAccountTokens checks for service accounts with risky token mounting.
func validateServiceAccountTokens(obj runtime.Object) []Finding <span class="cov4" title="9">{
        var findings []Finding

        // This rule primarily applies to RoleBindings/ClusterRoleBindings
        // that grant permissions to service accounts
        switch v := obj.(type) </span>{
        case *rbacv1.RoleBinding:<span class="cov2" title="3">
                for _, subject := range v.Subjects </span><span class="cov2" title="3">{
                        if subject.Kind == "ServiceAccount" </span><span class="cov2" title="2">{
                                // Check if the role grants sensitive permissions
                                if hasServiceAccountRisks(v.RoleRef.Name) </span><span class="cov1" title="1">{
                                        findings = append(findings, Finding{
                                                RuleID:      "RBAC005",
                                                RuleName:    "Avoid Service Account Token Automounting",
                                                Severity:    SeverityMedium,
                                                Message:     fmt.Sprintf("Service account '%s' bound to potentially risky role", subject.Name),
                                                Resource:    v.Name,
                                                Namespace:   v.Namespace,
                                                Kind:        "RoleBinding",
                                                Remediation: "Consider disabling automountServiceAccountToken for this service account or reducing permissions",
                                        })
                                }</span>
                        }
                }
        case *rbacv1.ClusterRoleBinding:<span class="cov1" title="1">
                for _, subject := range v.Subjects </span><span class="cov1" title="1">{
                        if subject.Kind == "ServiceAccount" </span><span class="cov1" title="1">{
                                if hasServiceAccountRisks(v.RoleRef.Name) </span><span class="cov1" title="1">{
                                        findings = append(findings, Finding{
                                                RuleID:      "RBAC005",
                                                RuleName:    "Avoid Service Account Token Automounting",
                                                Severity:    SeverityMedium,
                                                Message:     fmt.Sprintf("Service account '%s' in namespace '%s' bound to potentially risky cluster role", subject.Name, subject.Namespace),
                                                Resource:    v.Name,
                                                Namespace:   "",
                                                Kind:        "ClusterRoleBinding",
                                                Remediation: "Consider disabling automountServiceAccountToken for this service account or reducing permissions",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov4" title="9">return findings</span>
}

// hasServiceAccountRisks checks if a role name suggests risky permissions.
func hasServiceAccountRisks(roleName string) bool <span class="cov4" title="9">{
        riskyRoles := []string{"cluster-admin", "admin", "edit"}
        return slices.Contains(riskyRoles, roleName)
}</span>

// validateExecAttachPermissions checks for exec and attach permissions.
func validateExecAttachPermissions(obj runtime.Object) []Finding <span class="cov4" title="9">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"pods/exec", "pods/attach"},
                verbs:     []string{verbCreate},
                ruleID:    "RBAC006",
                ruleName:  "Restrict Exec and Attach Permissions",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov3" title="4">{
                        return fmt.Sprintf("Permission to %s containers found in %s", resource, kind)
                }</span>,
                remediation: "Limit exec/attach permissions to specific users/groups and implement additional authentication",
        })
}

// validateImpersonationPrivileges checks for impersonation permissions.
func validateImpersonationPrivileges(obj runtime.Object) []Finding <span class="cov4" title="8">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"users", "groups", "serviceaccounts"},
                verbs:     []string{"impersonate"},
                ruleID:    "RBAC007",
                ruleName:  "Limit Impersonation Privileges",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov3" title="5">{
                        return fmt.Sprintf("Impersonation permission for %s found in %s", resource, kind)
                }</span>,
                remediation: "Restrict impersonation to specific identities and implement strict auditing",
        })
}

// validateEscalateBindVerbs checks for escalate and bind permissions.
func validateEscalateBindVerbs(obj runtime.Object) []Finding <span class="cov4" title="8">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"roles", "clusterroles", "rolebindings", "clusterrolebindings"},
                verbs:     []string{"escalate", "bind"},
                ruleID:    "RBAC008",
                ruleName:  "Restrict Escalate and Bind Verbs",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov4" title="6">{
                        return fmt.Sprintf("Privilege escalation permissions on '%s' found in %s", resource, kind)
                }</span>,
                remediation: "Limit escalate/bind permissions to cluster administrators only",
        })
}

// validatePrivilegedContainerAccess checks for access to security-sensitive pod specs.
func validatePrivilegedContainerAccess(obj runtime.Object) []Finding <span class="cov4" title="7">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"podsecuritypolicies", "securitycontextconstraints"},
                verbs:     []string{"use"},
                ruleID:    "RBAC009",
                ruleName:  "Audit Privileged Container Access",
                severity:  SeverityHigh,
                getMessage: func(resource, _ string) string </span><span class="cov2" title="2">{
                        return fmt.Sprintf("Access to %s which may allow privileged containers", resource)
                }</span>,
                remediation: "Restrict PSP/SCC usage and audit all privileged container deployments",
        })
}

// validateNodePVAccess checks for direct node and persistent volume access.
func validateNodePVAccess(obj runtime.Object) []Finding <span class="cov4" title="9">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"nodes", "nodes/proxy", "persistentvolumes"},
                verbs:     []string{verbUpdate, verbPatch, verbDelete},
                ruleID:    "RBAC010",
                ruleName:  "Restrict Node and PersistentVolume Access",
                severity:  SeverityMedium,
                getMessage: func(resource, kind string) string </span><span class="cov3" title="4">{
                        return fmt.Sprintf("Direct write access to %s found in %s", resource, kind)
                }</span>,
                remediation: "Limit node/PV access to cluster operators and use PVCs for storage access",
        })
}

// validateWebhookAccess checks for webhook configuration permissions.
func validateWebhookAccess(obj runtime.Object) []Finding <span class="cov4" title="7">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"mutatingwebhookconfigurations", "validatingwebhookconfigurations"},
                verbs:     []string{verbCreate, verbUpdate, verbPatch},
                ruleID:    "RBAC011",
                ruleName:  "Limit Webhook Configuration Access",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov2" title="3">{
                        return fmt.Sprintf("Permission to modify %s found in %s", resource, kind)
                }</span>,
                remediation: "Restrict webhook configuration to cluster administrators only",
        })
}

// validateCRDAPIServiceAccess checks for CRD and APIService modification permissions.
func validateCRDAPIServiceAccess(obj runtime.Object) []Finding <span class="cov4" title="7">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"customresourcedefinitions", "apiservices"},
                verbs:     []string{verbCreate, verbUpdate, verbPatch, verbDelete},
                ruleID:    "RBAC012",
                ruleName:  "Restrict CRD and APIService Modifications",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov3" title="4">{
                        return fmt.Sprintf("Permission to modify %s found in %s", resource, kind)
                }</span>,
                remediation: "Limit CRD/APIService modifications to cluster administrators",
        })
}

// validateNamespaceIsolation checks for cross-namespace access patterns.
func validateNamespaceIsolation(obj runtime.Object) []Finding <span class="cov4" title="8">{
        var findings []Finding

        // Check RoleBindings that reference ClusterRoles
        if rb, ok := obj.(*rbacv1.RoleBinding); ok </span><span class="cov2" title="2">{
                if rb.RoleRef.Kind == kindClusterRole </span><span class="cov1" title="1">{
                        // This could indicate cross-namespace access
                        findings = append(findings, Finding{
                                RuleID:      "RBAC013",
                                RuleName:    "Separate Concerns with Namespace Isolation",
                                Severity:    SeverityMedium,
                                Message:     "RoleBinding references ClusterRole which may grant cross-namespace access",
                                Resource:    rb.Name,
                                Namespace:   rb.Namespace,
                                Kind:        "RoleBinding",
                                Remediation: "Consider using namespace-specific Roles instead of ClusterRoles for better isolation",
                        })
                }</span>
        }

        <span class="cov4" title="8">return findings</span>
}

// validateTokenCertificateRequests checks for token and certificate request permissions.
func validateTokenCertificateRequests(obj runtime.Object) []Finding <span class="cov4" title="8">{
        return checkResourceVerbAccess(obj, resourceVerbCheck{
                resources: []string{"serviceaccounts/token", "certificatesigningrequests"},
                verbs:     []string{verbCreate},
                ruleID:    "RBAC014",
                ruleName:  "Restrict TokenRequest and CertificateSigningRequest",
                severity:  SeverityHigh,
                getMessage: func(resource, kind string) string </span><span class="cov2" title="2">{
                        return fmt.Sprintf("Permission to create %s found in %s", resource, kind)
                }</span>,
                remediation: "Restrict token/certificate creation to authorized components only",
        })
}

// checkResourceVerbAccess is a helper function to check for specific resource/verb combinations.
type resourceVerbCheck struct {
        resources   []string
        verbs       []string
        ruleID      string
        ruleName    string
        severity    Severity
        getMessage  func(resource, kind string) string
        remediation string
}

func checkResourceVerbAccess(obj runtime.Object, check resourceVerbCheck) []Finding <span class="cov8" title="63">{
        var findings []Finding

        // Get rules and metadata based on object type
        var rules []rbacv1.PolicyRule
        var name, namespace, kind string

        switch v := obj.(type) </span>{
        case *rbacv1.Role:<span class="cov7" title="39">
                rules = v.Rules
                name = v.Name
                namespace = v.Namespace
                kind = "Role"</span>
        case *rbacv1.ClusterRole:<span class="cov6" title="24">
                rules = v.Rules
                name = v.Name
                namespace = ""
                kind = kindClusterRole</span>
        default:<span class="cov0" title="0">
                return findings</span>
        }

        // Check each rule
        <span class="cov8" title="63">for _, rule := range rules </span><span class="cov8" title="63">{
                findings = append(findings, checkSingleRule(rule, check, name, namespace, kind)...)
        }</span>

        <span class="cov8" title="63">return findings</span>
}

// checkSingleRule checks if a single rule matches the resource/verb criteria.
func checkSingleRule(rule rbacv1.PolicyRule, check resourceVerbCheck, name, namespace, kind string) []Finding <span class="cov8" title="63">{
        // Check if verbs match
        verbInfo := getMatchingVerbInfo(rule.Verbs, check.verbs)
        if verbInfo.count == 0 </span><span class="cov7" title="35">{
                return nil
        }</span>

        // Create findings for matching resources
        <span class="cov6" title="28">return createFindingsForResources(rule.Resources, check, verbInfo.count, name, namespace, kind)</span>
}

// verbMatchInfo encapsulates the result of analyzing RBAC verbs to determine
// how many security findings should be generated per resource.
//
// This type is used by the NIST RBAC validation rules to handle the special
// case where wildcard verbs ("*") should generate only one finding per resource,
// while explicit verb matches (e.g., ["create", "update"]) should generate one
// finding for each matching verb.
//
// For example:
//   - Rule with verbs ["*"] matching ["create", "update", "delete"] ‚Üí count = 1
//   - Rule with verbs ["create", "update"] matching ["create", "update", "delete"] ‚Üí count = 2
type verbMatchInfo struct {
        // count represents the number of findings to create for each matching resource.
        // When a wildcard verb is present, this will always be 1 regardless of how many
        // target verbs are being checked. For explicit verb matches, this equals the
        // number of verbs that match between the rule and the validation criteria.
        count int
}

// getMatchingVerbInfo analyzes verbs and returns match information.
func getMatchingVerbInfo(ruleVerbs []string, targetVerbs []string) verbMatchInfo <span class="cov8" title="63">{
        var matchCount int
        hasWildcard := false

        for _, verb := range ruleVerbs </span><span class="cov8" title="95">{
                if verb == "*" </span><span class="cov5" title="14">{
                        hasWildcard = true
                        break</span>
                }
                // Count matching verbs
                <span class="cov8" title="81">for _, target := range targetVerbs </span><span class="cov10" title="169">{
                        if verb == target </span><span class="cov6" title="19">{
                                matchCount++
                        }</span>
                }
        }

        // If wildcard verb, create only one finding per resource
        <span class="cov8" title="63">if hasWildcard </span><span class="cov5" title="14">{
                return verbMatchInfo{count: 1}
        }</span>

        <span class="cov7" title="49">return verbMatchInfo{count: matchCount}</span>
}

// createFindingsForResources creates findings for each matching resource.
func createFindingsForResources(
        resources []string,
        check resourceVerbCheck,
        verbCount int,
        name, namespace, kind string,
) []Finding <span class="cov6" title="28">{
        var findings []Finding

        for _, resource := range resources </span><span class="cov7" title="32">{
                if resource == "*" </span><span class="cov0" title="0">{
                        // Wildcard matches all target resources
                        findings = append(
                                findings,
                                createFindingsForTargets(check.resources, check, verbCount, name, namespace, kind)...)
                        break</span> // Don't process more after wildcard
                }

                // Check specific resource matches
                <span class="cov7" title="32">for _, target := range check.resources </span><span class="cov8" title="84">{
                        if resource == target </span><span class="cov6" title="24">{
                                findings = append(
                                        findings,
                                        createMultipleFindings(resource, check, verbCount, name, namespace, kind)...)
                        }</span>
                }
        }

        <span class="cov6" title="28">return findings</span>
}

// createFindingsForTargets creates findings for multiple target resources.
func createFindingsForTargets(
        targets []string,
        check resourceVerbCheck,
        verbCount int,
        name, namespace, kind string,
) []Finding <span class="cov0" title="0">{
        var findings []Finding
        for _, target := range targets </span><span class="cov0" title="0">{
                findings = append(findings, createMultipleFindings(target, check, verbCount, name, namespace, kind)...)
        }</span>
        <span class="cov0" title="0">return findings</span>
}

// createMultipleFindings creates the specified number of findings for a resource.
func createMultipleFindings(
        resource string,
        check resourceVerbCheck,
        count int,
        name, namespace, kind string,
) []Finding <span class="cov6" title="24">{
        findings := make([]Finding, 0, count)
        for range count </span><span class="cov6" title="30">{
                findings = append(findings, Finding{
                        RuleID:      check.ruleID,
                        RuleName:    check.ruleName,
                        Severity:    check.severity,
                        Message:     check.getMessage(resource, kind),
                        Resource:    name,
                        Namespace:   namespace,
                        Kind:        kind,
                        Remediation: check.remediation,
                })
        }</span>
        <span class="cov6" title="24">return findings</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package validator

import (
        "fmt"

        "k8s.io/apimachinery/pkg/runtime"

        rbacv1 "k8s.io/api/rbac/v1"
)

// Validator validates RBAC resources against security policies.
type Validator struct {
        rules []Rule
}

// Rule represents a validation rule.
type Rule struct {
        ID          string
        Name        string
        Description string
        Severity    Severity
        Validate    func(obj runtime.Object) []Finding
}

// Severity represents the severity of a finding.
type Severity string

const (
        SeverityHigh   Severity = "HIGH"
        SeverityMedium Severity = "MEDIUM"
        SeverityLow    Severity = "LOW"
        SeverityInfo   Severity = "INFO"
)

// Finding represents a validation finding.
type Finding struct {
        RuleID      string
        RuleName    string
        Severity    Severity
        Message     string
        Resource    string
        Namespace   string
        Kind        string
        Remediation string
}

// New creates a new Validator with default rules.
func New() *Validator <span class="cov3" title="3">{
        return &amp;Validator{
                rules: defaultRules(),
        }
}</span>

// NewWithRules creates a new Validator with custom rules.
func NewWithRules(rules []Rule) *Validator <span class="cov1" title="1">{
        return &amp;Validator{
                rules: rules,
        }
}</span>

// Validate validates a Kubernetes object.
func (v *Validator) Validate(obj runtime.Object) []Finding <span class="cov4" title="5">{
        var findings []Finding

        for _, rule := range v.rules </span><span class="cov10" title="70">{
                ruleFindings := rule.Validate(obj)
                findings = append(findings, ruleFindings...)
        }</span>

        <span class="cov4" title="5">return findings</span>
}

// ValidateAll validates multiple Kubernetes objects.
func (v *Validator) ValidateAll(objects []runtime.Object) []Finding <span class="cov1" title="1">{
        var allFindings []Finding

        for _, obj := range objects </span><span class="cov2" title="2">{
                findings := v.Validate(obj)
                allFindings = append(allFindings, findings...)
        }</span>

        <span class="cov1" title="1">return allFindings</span>
}

// defaultRules returns the default set of validation rules.
func defaultRules() []Rule <span class="cov4" title="5">{
        return []Rule{
                {
                        ID:          "RBAC001",
                        Name:        "Avoid Wildcard Permissions",
                        Description: "Using wildcard (*) in verbs, resources, or apiGroups can grant excessive permissions",
                        Severity:    SeverityHigh,
                        Validate:    validateWildcardPermissions,
                },
                {
                        ID:          "RBAC002",
                        Name:        "Avoid Cluster-Admin Binding",
                        Description: "Binding to cluster-admin role should be avoided unless absolutely necessary",
                        Severity:    SeverityHigh,
                        Validate:    validateClusterAdminBinding,
                },
                {
                        ID:          "RBAC003",
                        Name:        "Avoid Secrets Access",
                        Description: "Direct access to secrets should be limited and audited",
                        Severity:    SeverityMedium,
                        Validate:    validateSecretsAccess,
                },
                {
                        ID:          "RBAC004",
                        Name:        "Prefer Namespaced Roles",
                        Description: "Use Role instead of ClusterRole when permissions are only needed in specific namespaces",
                        Severity:    SeverityLow,
                        Validate:    validateNamespacedRoles,
                },
                // NIST SP 800-190 based rules
                {
                        ID:          "RBAC005",
                        Name:        "Avoid Service Account Token Automounting",
                        Description: "Service accounts with excessive permissions should not automount tokens (NIST SP 800-190)",
                        Severity:    SeverityMedium,
                        Validate:    validateServiceAccountTokens,
                },
                {
                        ID:          "RBAC006",
                        Name:        "Restrict Exec and Attach Permissions",
                        Description: "Exec and attach verbs allow interactive container access and should be restricted (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateExecAttachPermissions,
                },
                {
                        ID:          "RBAC007",
                        Name:        "Limit Impersonation Privileges",
                        Description: "Impersonation allows users to act as other users/groups and should be strictly limited (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateImpersonationPrivileges,
                },
                {
                        ID:          "RBAC008",
                        Name:        "Restrict Escalate and Bind Verbs",
                        Description: "Escalate and bind verbs can lead to privilege escalation (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateEscalateBindVerbs,
                },
                {
                        ID:          "RBAC009",
                        Name:        "Audit Privileged Container Access",
                        Description: "Access to privileged containers and host namespaces should be audited (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validatePrivilegedContainerAccess,
                },
                {
                        ID:          "RBAC010",
                        Name:        "Restrict Node and PersistentVolume Access",
                        Description: "Direct node and persistent volume access should be restricted (NIST SP 800-190)",
                        Severity:    SeverityMedium,
                        Validate:    validateNodePVAccess,
                },
                {
                        ID:          "RBAC011",
                        Name:        "Limit Webhook Configuration Access",
                        Description: "Webhook configurations can intercept API requests and should be protected (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateWebhookAccess,
                },
                {
                        ID:          "RBAC012",
                        Name:        "Restrict CRD and APIService Modifications",
                        Description: "Custom Resource Definitions and API services extend the API and require protection (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateCRDAPIServiceAccess,
                },
                {
                        ID:          "RBAC013",
                        Name:        "Separate Concerns with Namespace Isolation",
                        Description: "Cross-namespace access should be minimized for proper isolation (NIST SP 800-190)",
                        Severity:    SeverityMedium,
                        Validate:    validateNamespaceIsolation,
                },
                {
                        ID:          "RBAC014",
                        Name:        "Restrict TokenRequest and CertificateSigningRequest",
                        Description: "Token and certificate requests can be used for authentication bypass (NIST SP 800-190)",
                        Severity:    SeverityHigh,
                        Validate:    validateTokenCertificateRequests,
                },
        }
}</span>

// validateWildcardPermissions checks for wildcard usage in permissions.
func validateWildcardPermissions(obj runtime.Object) []Finding <span class="cov5" title="8">{
        var findings []Finding

        switch v := obj.(type) </span>{
        case *rbacv1.Role:<span class="cov3" title="4">
                findings = checkRulesForWildcards(v.Rules, v.Name, v.Namespace, "Role")</span>
        case *rbacv1.ClusterRole:<span class="cov3" title="3">
                findings = checkRulesForWildcards(v.Rules, v.Name, "", "ClusterRole")</span>
        }

        <span class="cov5" title="8">return findings</span>
}

// checkRulesForWildcards checks PolicyRules for wildcard usage.
func checkRulesForWildcards(rules []rbacv1.PolicyRule, name, namespace, kind string) []Finding <span class="cov5" title="10">{
        var findings []Finding

        for _, rule := range rules </span><span class="cov5" title="10">{
                // Check for wildcard in verbs
                for _, verb := range rule.Verbs </span><span class="cov6" title="13">{
                        if verb == "*" </span><span class="cov3" title="4">{
                                findings = append(findings, Finding{
                                        RuleID:      "RBAC001",
                                        RuleName:    "Avoid Wildcard Permissions",
                                        Severity:    SeverityHigh,
                                        Message:     fmt.Sprintf("Wildcard verb '*' found in %s", kind),
                                        Resource:    name,
                                        Namespace:   namespace,
                                        Kind:        kind,
                                        Remediation: "Replace wildcard verb with specific verbs like 'get', 'list', 'watch', 'create', 'update', 'patch', 'delete'",
                                })
                        }</span>
                }

                // Check for wildcard in resources
                <span class="cov5" title="10">for _, resource := range rule.Resources </span><span class="cov5" title="10">{
                        if resource == "*" </span><span class="cov3" title="4">{
                                findings = append(findings, Finding{
                                        RuleID:      "RBAC001",
                                        RuleName:    "Avoid Wildcard Permissions",
                                        Severity:    SeverityHigh,
                                        Message:     fmt.Sprintf("Wildcard resource '*' found in %s", kind),
                                        Resource:    name,
                                        Namespace:   namespace,
                                        Kind:        kind,
                                        Remediation: "Replace wildcard resource with specific resources like 'pods', 'services', 'deployments'",
                                })
                        }</span>
                }

                // Check for wildcard in API groups
                <span class="cov5" title="10">for _, apiGroup := range rule.APIGroups </span><span class="cov5" title="10">{
                        if apiGroup == "*" </span><span class="cov3" title="4">{
                                findings = append(findings, Finding{
                                        RuleID:      "RBAC001",
                                        RuleName:    "Avoid Wildcard Permissions",
                                        Severity:    SeverityHigh,
                                        Message:     fmt.Sprintf("Wildcard API group '*' found in %s", kind),
                                        Resource:    name,
                                        Namespace:   namespace,
                                        Kind:        kind,
                                        Remediation: "Replace wildcard API group with specific groups like '', 'apps', 'batch'",
                                })
                        }</span>
                }
        }

        <span class="cov5" title="10">return findings</span>
}

// validateClusterAdminBinding checks for bindings to cluster-admin role.
func validateClusterAdminBinding(obj runtime.Object) []Finding <span class="cov5" title="8">{
        var findings []Finding

        switch v := obj.(type) </span>{
        case *rbacv1.ClusterRoleBinding:<span class="cov2" title="2">
                if v.RoleRef.Name == "cluster-admin" </span><span class="cov1" title="1">{
                        findings = append(findings, Finding{
                                RuleID:      "RBAC002",
                                RuleName:    "Avoid Cluster-Admin Binding",
                                Severity:    SeverityHigh,
                                Message:     "ClusterRoleBinding references cluster-admin role",
                                Resource:    v.Name,
                                Namespace:   "",
                                Kind:        "ClusterRoleBinding",
                                Remediation: "Create a custom ClusterRole with only the required permissions instead of using cluster-admin",
                        })
                }</span>
        case *rbacv1.RoleBinding:<span class="cov1" title="1">
                if v.RoleRef.Kind == "ClusterRole" &amp;&amp; v.RoleRef.Name == "cluster-admin" </span><span class="cov1" title="1">{
                        findings = append(findings, Finding{
                                RuleID:      "RBAC002",
                                RuleName:    "Avoid Cluster-Admin Binding",
                                Severity:    SeverityHigh,
                                Message:     "RoleBinding references cluster-admin ClusterRole",
                                Resource:    v.Name,
                                Namespace:   v.Namespace,
                                Kind:        "RoleBinding",
                                Remediation: "Create a custom Role or ClusterRole with only the required permissions instead of using cluster-admin",
                        })
                }</span>
        }

        <span class="cov5" title="8">return findings</span>
}

// validateSecretsAccess checks for direct access to secrets.
//
//nolint:gocognit // Secret access validation requires complex rule evaluation
func validateSecretsAccess(obj runtime.Object) []Finding <span class="cov5" title="10">{
        var findings []Finding

        checkSecretsInRules := func(rules []rbacv1.PolicyRule, name, namespace, kind string) </span><span class="cov5" title="10">{
                for _, rule := range rules </span><span class="cov5" title="10">{
                        for _, resource := range rule.Resources </span><span class="cov6" title="11">{
                                if resource == "secrets" </span><span class="cov4" title="5">{
                                        hasGet := false
                                        hasList := false

                                        for _, verb := range rule.Verbs </span><span class="cov5" title="7">{
                                                switch verb </span>{
                                                case "get":<span class="cov2" title="2">
                                                        hasGet = true</span>
                                                case "list":<span class="cov2" title="2">
                                                        hasList = true</span>
                                                case "*":<span class="cov1" title="1">
                                                        hasGet = true
                                                        hasList = true</span>
                                                }
                                        }

                                        <span class="cov4" title="5">if hasGet || hasList </span><span class="cov3" title="4">{
                                                findings = append(findings, Finding{
                                                        RuleID:      "RBAC003",
                                                        RuleName:    "Avoid Secrets Access",
                                                        Severity:    SeverityMedium,
                                                        Message:     fmt.Sprintf("Direct read access to secrets found in %s", kind),
                                                        Resource:    name,
                                                        Namespace:   namespace,
                                                        Kind:        kind,
                                                        Remediation: "Limit secrets access to specific named resources or use service accounts with mounted secrets instead",
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov5" title="10">switch v := obj.(type) </span>{
        case *rbacv1.Role:<span class="cov5" title="7">
                checkSecretsInRules(v.Rules, v.Name, v.Namespace, "Role")</span>
        case *rbacv1.ClusterRole:<span class="cov3" title="3">
                checkSecretsInRules(v.Rules, v.Name, "", "ClusterRole")</span>
        }

        <span class="cov5" title="10">return findings</span>
}

// validateNamespacedRoles suggests using Role instead of ClusterRole for namespace-scoped resources.
func validateNamespacedRoles(obj runtime.Object) []Finding <span class="cov5" title="10">{
        var findings []Finding

        if cr, ok := obj.(*rbacv1.ClusterRole); ok </span><span class="cov4" title="6">{
                // Check if all rules only reference namespace-scoped resources
                allNamespaced := true
                namespacedResources := map[string]bool{
                        "pods":         true,
                        "services":     true,
                        "deployments":  true,
                        "replicasets":  true,
                        "statefulsets": true,
                        "daemonsets":   true,
                        "configmaps":   true,
                        "secrets":      true,
                        "ingresses":    true,
                        "jobs":         true,
                        "cronjobs":     true,
                }

                for _, rule := range cr.Rules </span><span class="cov4" title="6">{
                        for _, resource := range rule.Resources </span><span class="cov5" title="7">{
                                if resource == "*" || !namespacedResources[resource] </span><span class="cov3" title="3">{
                                        allNamespaced = false
                                        break</span>
                                }
                        }
                        <span class="cov4" title="6">if !allNamespaced </span><span class="cov3" title="3">{
                                break</span>
                        }
                }

                <span class="cov4" title="6">if allNamespaced &amp;&amp; len(cr.Rules) &gt; 0 </span><span class="cov2" title="2">{
                        findings = append(findings, Finding{
                                RuleID:      "RBAC004",
                                RuleName:    "Prefer Namespaced Roles",
                                Severity:    SeverityLow,
                                Message:     "ClusterRole only contains namespace-scoped resources",
                                Resource:    cr.Name,
                                Namespace:   "",
                                Kind:        "ClusterRole",
                                Remediation: "Consider using a Role instead of ClusterRole for namespace-scoped permissions",
                        })
                }</span>
        }

        <span class="cov5" title="10">return findings</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
